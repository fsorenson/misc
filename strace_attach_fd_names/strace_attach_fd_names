#!/usr/bin/perl -w

use strict;
use warnings;

use List::MoreUtils qw/indexes/;
use File::Basename qw/basename/;
use Getopt::Long;

use Data::Dumper;
use Devel::StackTrace;
use constant { true => 1, false => 0 };

my %config = (
	'debug' => 0,
	'show_execnames' => false,
);


GetOptions(
	'debug|verbose|v+' => \$config{'debug'},
	'execnames|e' => sub { $config{'show_execnames'} = true },
);


if ($config{'debug'} >= 1) {
	printf("resulting DEBUG: %d\n", $config{'debug'});
	printf("resulting config{'debug'}: %d\n", $config{'debug'});
	printf("resulting show_execname: $config{'show_execnames'}\n");
}


STDOUT->autoflush(1);



#my %fd_mappings; # map fds per pid
#my %fd_cloexecs; # fds to close on exec, per pid

# if a clone() is done with CLONE_FILES, the processes share an fd table...
# this contains mappings from a pid back to the process holding the actual fd table
# if execve is later called for this pid, the original fd table is duplicated, and this mapping is removed
my %shared_fd_tables;

my %tracking_data = ();



my %patterns;
my %regexes;
my @generic_fd_functions;
my @generic_dfd_pathname_functions;
my @no_parsing_functions;


sub dump_backtrace {
	my $trace = Devel::StackTrace->new;
	printf("\n");
	print $trace->as_string;
	printf("\n");
}
sub trim {
	my $s = shift;
	$s =~ s/^\s+|\s+$//g;
	return $s
}
sub get_match_val {
	my $str = shift;
	return (defined($str) ? trim($str) : "undefined");
}

sub get_cwd {
	my $pid = shift;

	$pid = -1 if (!defined($pid));

	local *_get_cwd = sub {
		my $pid = shift;

		return $tracking_data{$pid}{'cwd'} if (defined($tracking_data{$pid}{'cwd'}));
		return "";
	};
	my $result = _get_cwd($pid);
	printf("get_cwd(pid: %s): '%s'\n",
		(($pid > 0) ? $pid : "nopid"), $result) if ($config{'debug'} >= 1);
	return $result;
}
sub set_cwd {
	my $pid = shift;
	my $cwd = shift;

	return if (!defined($cwd));
	$pid = -1 if (!defined($pid));

	local *_set_cwd = sub {
		my $pid = shift;
		my $cwd = shift;

		$tracking_data{$pid}{'cwd'} = $cwd;
	};
	_set_cwd($pid, $cwd);
}
sub set_execname {
	my $pid = shift;
	my $exe = shift;

	return if (!$config{'show_execnames'});
	return if (!defined($exe));
	$pid = -1 if (!defined($pid));

	local *_set_execname = sub {
		my $pid = shift;
		my $exe = shift;

		$tracking_data{$pid}{'execname'} = $exe;
		return $tracking_data{$pid}{'execname'};
	};
	my $result = _set_execname($pid, $exe);
	printf("set_execname(%s, %s) (%s)\n", $pid, $exe, $tracking_data{$pid}{'execname'}) if ($config{'debug'} >= 1);
	return $result;
}
sub get_execname {
	my $pid = shift;

	return "" if (!$config{'show_execnames'});
	$pid = -1 if (!defined($pid));

	local *_get_execname = sub {
		my $pid = shift;

		return "" if (!defined($tracking_data{$pid}{'execname'}));
		return $tracking_data{$pid}{'execname'};
	};
	my $result = _get_execname($pid);
	printf("get_execname(%s) -> '%s'\n",
		get_match_val($pid), $result) if ($config{'debug'} >= 1);
	return $result;
}

sub get_shared_fd_table_mapping {
	my $pid = shift;

	$pid = -1 if (!defined($pid));
	return $pid if ($pid == -1);

	if (defined($shared_fd_tables{$pid})) {
		# this pid actually shares a table with another pid
		# map to that pid before trying to do anything here
		printf("mapping pid %d to shared fd table of pid %d\n",
			$pid, $shared_fd_tables{$pid}) if ($config{'debug'} >= 1);
		return $shared_fd_tables{$pid};
	}
	return $pid;
}
# store_shared_fd_table_mapping(new_pid, pid_of_table_to_share)
sub store_shared_fd_table_mapping {
	my $new_pid = shift;
	my $target = shift;

	return if (!defined($new_pid) || $new_pid == -1);
	return if (!defined($target) || $target == -1);

	$target = get_shared_fd_table_mapping($target); # is target already sharing?
	$shared_fd_tables{$new_pid} = $target;
}
# copy (not share) fds
sub inherit_fd_table {
	my $new_pid = shift;
	my $orig_pid = shift;

	return if (!defined($new_pid) || $new_pid == -1);
	return if (!defined($orig_pid) || $orig_pid == -1);

	$orig_pid = get_shared_fd_table_mapping($orig_pid);

	my @fds = keys(%{$tracking_data{$orig_pid}{'fd_mappings'}});
	foreach my $fd (@fds) {
		store_fd_name($new_pid, $fd, get_fd_path($orig_pid, $fd));
	}
	printf("copied fd table of pid %d to pid %d\n", $orig_pid, $new_pid) if ($config{'debug'} >= 1);
	# TODO - duplicate cloexec table?
}
sub clear_fd_table { # call when process is exiting
	my $pid = shift;

	$pid = -1 if (!defined($pid));
	undef($tracking_data{$pid}{'fd_mappings'}) if (defined($tracking_data{$pid}{'fd_mappings'}));

	printf("cleared fd table for pid %d\n", $pid) if ($config{'debug'} >= 1);
}
sub dump_fd_mappings {
	my @pids = keys(%tracking_data);
	printf("indexes: %s\n", join(" ", @pids));

	foreach my $pid (@pids) {
		printf("pid %d\n", $pid);

		my @fds = keys(%{$tracking_data{$pid}{'fd_mappings'}});
		foreach my $fd (sort { $a <=> $b} (keys(%{$tracking_data{$pid}{'fd_mappings'}}))) {
			printf("fd: %d - '%s'\n", $fd, $tracking_data{$pid}{'fd_mappings'}{$fd});
		}
	}
}

sub store_cloexec_fd {
	my $pid = shift;
	my $fd = shift;

	$pid = -1 if (!defined($pid));
	$tracking_data{$pid}{'cloexec'}{$fd} = true;
	printf("stored pid %d fd %d CLOEXEC\n", $pid, $fd) if ($config{'debug'} >= 1);
}
sub drop_cloexec_fd {
	my $pid = shift;
	my $fd = shift;

	$pid = -1 if (!defined($pid));
	$pid = get_shared_fd_table_mapping($pid);
	undef($tracking_data{$pid}{'cloexec'}{$fd}) if (defined($tracking_data{$pid}{'cloexec'}{$fd}));
	printf("removed pid %d fd %d CLOEXEC\n", $pid, $fd) if ($config{'debug'} >= 1);
}
sub store_fd_name {
	my $pid = shift;
	my $fd = shift;
	my $path = shift;

	$path =~ s/^<|>$//g;

	$pid = -1 if (!defined($pid));
	$pid = get_shared_fd_table_mapping($pid);

	return if ($fd < 0);

	$tracking_data{$pid}{'fd_mappings'}{$fd} = $path;
	printf("storing pid: %d fd: %d -> %s\n", $pid, $fd, $path) if ($config{'debug'} >= 1);
}
sub drop_fd_name {
	my $pid = shift;
	my $fd = shift;

	$pid = -1 if (!defined($pid));
	$pid = get_shared_fd_table_mapping($pid);

	undef($tracking_data{$pid}{'fd_mappings'}{$fd}) if (defined($tracking_data{$pid}{'fd_mappings'}{$fd}));
}
sub get_dfd_path {
	my $pid = shift;
	my $dfd = shift;

	local *_get_dfd_path = sub {
		my $pid = shift;
		my $dfd = shift;

		return get_cwd($pid) if ($dfd eq "AT_FDCWD");
		return get_fd_path($pid, $dfd);
	};
	my $result = _get_dfd_path($pid, $dfd);
	printf("get_dfd_path(pid: %s, dfd: %s) -> '%s'\n",
		get_match_val($pid), $dfd, $result) if ($config{'debug'} >= 1);
	return $result;
}
sub get_fd_path {
	my $pid = shift;
	my $fd = shift;

	$pid = -1 if (!defined($pid));
	local *_get_fd_path = sub {
		my $pid = shift;
		my $fd = shift;

		return get_cwd($pid) if ($fd eq "AT_FDCWD");

		$pid = get_shared_fd_table_mapping($pid);

		return $tracking_data{$pid}{'fd_mappings'}{$fd} if (defined($tracking_data{$pid}{'fd_mappings'}{$fd}));
		return "";
	};
	my $result = _get_fd_path($pid, $fd);
	printf("get_fd_path(pid: %s, fd: %s) -> '%s'\n",
		get_match_val($pid), $fd, $result) if ($config{'debug'} >= 1);
	return $result;
}
sub get_atpath {
	my $pid = shift;
	my $dfd = shift;
	my $path = shift;

	$pid = -1 if (!defined($pid));
	local *_get_atpath = sub {
		my $pid = shift;
		my $dfd = shift;
		my $path = shift;

		# if pathname is absolute, dirfd is ignored
		return $path if (substr($path, 0, 1) eq "/");

 	       # If pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the current working directory of the calling process (like open()).
#		return get_cwd($pid) . "/" . $path if ($dfd eq "AT_FDCWD");
		if ($dfd eq "AT_FDCWD") {
			my $cwd = get_cwd($pid);

			return $cwd if ($cwd ne "" and $path eq ".");
			return $cwd . "/" . $path if ($cwd ne "");
			return $path;
		}

		# dirfd is not AT_FDCWD and the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the file descriptor dirfd (rather than relative to the current working directory of the calling process, as is done by open() for a relative pathname).

		my $fd_path = get_fd_path($pid, $dfd);
		return $fd_path if ($fd_path ne "" and $path eq ".");
		return $fd_path . "/" . $path if ($fd_path ne "");

		# return one of these, depending on which we decide we like best
		return "<" . $dfd . ">/" . $path;
		return $path;
	};

	my $result = _get_atpath($pid, $dfd, $path);
	printf("get_atpath for pid: %s, dfd: '%s', path: '%s' -> '%s'\n",
		get_match_val($pid), $dfd, $path, $result) if ($config{'debug'} >= 1);
	return $result;
}

sub store_unfinished {
	my $pid = shift;
	my $store_line = shift;

	$tracking_data{$pid}{'unfinished'} = $store_line;
}
sub retrieve_unfinished {
	my $pid = shift;
	my $ret = "";

	if (defined($tracking_data{$pid}{'unfinished'})) {
		$ret = $tracking_data{$pid}{'unfinished'};
		undef($tracking_data{$pid}{'unfinished'});
	}
	return $ret;
}
sub is_generic_fd_function {
	my $op = shift;

	if ($config{'debug'} >= 2) {
		foreach my $o (@generic_fd_functions) {
			printf("testing whether '%s' matches '%s'\n", $op, $o);
		}
	}
	return (grep { $_ eq $op } @generic_fd_functions);
}
sub is_generic_dfd_path_function {
	my $op = shift;

	if ($config{'debug'} >= 2) {
		foreach my $o (@generic_dfd_pathname_functions) {
			printf("testing whether '%s' matches '%s'\n", $op, $o);
		}
	}
	return (grep { $_ eq $op } @generic_dfd_pathname_functions);
}
sub do_not_parse_function {
	my $op = shift;
	return (grep { $_ eq $op } @no_parsing_functions);
}
sub ret_is_error {
	my $ret = shift;

	if (!defined($ret)) {
dump_backtrace();
exit(1);
	}

	return ($ret =~ $regexes{'return_error'});
}


%patterns = (
#	'possible_pid_string' => '(?:([0-9]+)\s+)?',
	#[pid 15218]
	#	'possible_pid_string' => '(?:([0-9]+|(?:\[pid ([0-9]+)\]))\s+)?',
	#	'possible_pid_string' => '(?:([0-9]+)|(?:\[pid ([0-9]+)\])\s+)?',
	'possible_pid_string' => '(?:([0-9]+|(?:\[pid )[0-9]+(?:\]))\s+)?',


	'possible_timestamp_string' => '(?:([0-9:\.]+)\s+)?',
	'op_string' => '([^\( ]+)',
	'op_args_string' => '(.*?)',
	'ret_string' => '(?:\s+= (.+?))',
	'possible_elapsed_string' => '(?: <([0-9]+\.[0-9]+)>)?',

	'quoted_string' => "(?:\"(.+)\")",
	'squiggle_braces_arg' => "(?:\{(.+)\})",

	'digits_string' => '[0-9]+',
	'hex_string' => '0x[0-9a-f]+',
	'hex_string_or_null' => '(?:0x[0-9a-f]+|NULL)',
	'fd_string' => "[0-9]+",
	'fd_string_or_negative_one' => '(?:[0-9]+|-1)',
	'atfdcwd_string' => "AT_FDCWD",

	'possible_path_string' => "(?:<(.+)>)?",
	'file_mode_string' => "0[0-7]+",
	'possible_file_mode_string' => "(?:, (0[0-7]+))?",

	'proc_pid_exe' => '(?:"/proc/([0-9]+|self)/exe")',

	'possible_pipefd_name' => "(?:<(.+)>)?",
	'possible_sockfd_name' => "(?:<(.+)>)?",

	'newfstatat_flags' => "(0|(?:\||AT_EMPTY_PATH|AT_NO_AUTOMOUNT|AT_SYMLINK_NOFOLLOW)+)",

	# man clone | egrep -o 'CLONE_[^ ,.)]+' | sort -u | paste -s - -d\|
#	'clone_flags' => '(0|(?:\|CLONE_[^\|, ]+
#	'clone_flags' => '(0|(?:\|CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|CLONE_DETACHED|CLONE_FILES|CLONE_FS|CLONE_IO|CLONE_NEWIPC|CLONE_NEWNET|CLONE_NEWNS|CLONE_NEWPID|CLONE_NEWUTS|CLONE_PARENT|CLONE_PARENT_SETTID|CLONE_PID|CLONE_PTRACE|CLONE  _SETTID|CLONE_SETTLS|CLONE_SIGHAND|CLONE_STOPPED|CLONE_SYSVSEM|CLONE_THREAD|CLONE_UNTRACED|CLONE_VFORK|CLONE_VM)+)',

	'signal_name' => '(?:SIG[A-Z0-9]+)',

	'clone_flags' => '(0|(?:\\||CLONE_[A-Z0-9_]+|SIG[A-Z0-9]+)+)',

	'open_flags' => "(0|(?:\\||O_[A-Z0-9_]+)+)",
	'dup3_flags' => "(0|O_CLOEXEC)",

	'fcntl_cmd' => '(F_[^, ]+)',
#	'fcntl_args' => '(.+)?',
	'possible_other_args' => "(?:, (.+))?",

#	'generic_arg' => '(?:, (.+?))',
	'generic_arg' => '(.+?)',

	'execve_path_string' => '(?:"([^"]+)")',
	'execve_argv_string' => '(?:\[([^\]]+)\])',
	'execve_envp_string' => '(?:\[(.+)\])',

	'socket_domain' => '(?:AF_[A-Z0-9]+)',
	'socket_type' => '(?:SOCK_[A-Z]+)',
	'socket_proto' => '(?:0)',

	'everything_else' => "(.+)?",

	'return_error_string' => "-1 (E[^ ]+)\((.+)\)",
);

# build on previous definitions
$patterns{'fd_with_possible_path'} = "($patterns{'fd_string'})$patterns{'possible_path_string'}";
$patterns{'fd_or_negative_one_with_possible_path'} = "($patterns{'fd_string_or_negative_one'})$patterns{'possible_path_string'}";

$patterns{'fd_or_atfdcwd_string'} = "($patterns{'fd_string'}|$patterns{'atfdcwd_string'})";
$patterns{'fd_or_atfdcwd_with_possible_path'} = "$patterns{'fd_or_atfdcwd_string'}$patterns{'possible_path_string'}";
$patterns{'fcntl_args'} = "$patterns{'possible_other_args'}";

$patterns{'pipefd_with_possible_name'} = "($patterns{'fd_string'})$patterns{'possible_pipefd_name'}";
$patterns{'sockfd_with_possible_name'} = "($patterns{'fd_string'})$patterns{'possible_sockfd_name'}";
$patterns{'siginfo_t'} = "(?:\{si_signo=(?:SIG[A-Z0-9]+), si_code.+\})";



%regexes = (
	'unfinished' => qr/^$patterns{'possible_pid_string'}$patterns{'possible_timestamp_string'}$patterns{'op_string'}\($patterns{'op_args_string'} <unfinished ...>$/,
	'resumed' => qr/^$patterns{'possible_pid_string'}$patterns{'possible_timestamp_string'}<... $patterns{'op_string'} resumed>$patterns{'everything_else'}$/,


	'op' => qr/^$patterns{'possible_pid_string'}$patterns{'possible_timestamp_string'}$patterns{'op_string'}\($patterns{'op_args_string'}\)$patterns{'ret_string'}$patterns{'possible_elapsed_string'}$/,
	'process_exited' => qr/^$patterns{'possible_pid_string'}$patterns{'possible_timestamp_string'}\+\+\+ exited with ($patterns{'digits_string'}) \+\+\+/,
	'process_signal' => qr/^$patterns{'possible_pid_string'}$patterns{'possible_timestamp_string'}--- ($patterns{'signal_name'}) ($patterns{'siginfo_t'}) ---/,
	'strace_partial_line' => qr/^$patterns{'possible_pid_string'}$patterns{'possible_timestamp_string'}(.+)/,


	'getcwd' => qr/^$patterns{'quoted_string'}, $patterns{'digits_string'}/, # don't capture digits unless we come up with a reason later

#	'fstat' => qr/^$patterns{'fd_with_possible_path'}, $patterns{'squiggle_braces_arg'}$/,
	'newfstatat' => qr/^$patterns{'fd_or_atfdcwd_with_possible_path'}, $patterns{'quoted_string'}, $patterns{'squiggle_braces_arg'}, $patterns{'newfstatat_flags'}$/,

	'creat' => qr/^$patterns{'quoted_string'}, $patterns{'file_mode_string'}$/,

	'open' => qr/^$patterns{'quoted_string'}, $patterns{'open_flags'}$patterns{'possible_file_mode_string'}$/,
	'openat' => qr/^$patterns{'fd_or_atfdcwd_with_possible_path'}, $patterns{'quoted_string'}, $patterns{'open_flags'}$patterns{'possible_file_mode_string'}$/,

	'close' => qr/^$patterns{'fd_with_possible_path'}$/,

	'chdir' => qr/^$patterns{'quoted_string'}/,
	'fchdir' => qr/^$patterns{'fd_with_possible_path'}$/,

#	'fcntl' => qr/^$patterns{'fd_with_possible_path'}, $patterns{'fcntl_cmd'}$patterns{'fcntl_args'}/,
	'fcntl' => qr/^$patterns{'fd_with_possible_path'}, $patterns{'fcntl_cmd'}$patterns{'possible_other_args'}/,


#	'mmap' => qr/^$patterns{'generic_arg'}, $patterns{'generic_arg'}, $patterns{'generic_arg'}, $patterns{'generic_arg'}, $patterns{'fd_with_possible_path'}, $patterns{'generic_arg'}/,
	'mmap' => qr/^$patterns{'generic_arg'}, $patterns{'generic_arg'}, $patterns{'generic_arg'}, $patterns{'generic_arg'}, $patterns{'fd_or_negative_one_with_possible_path'}, $patterns{'generic_arg'}/,

	'dup' => qr/^$patterns{'fd_with_possible_path'}/,
	'dup2' => qr/^$patterns{'fd_with_possible_path'}, ($patterns{'fd_string'})$/,
	'dup3' => qr/^$patterns{'fd_with_possible_path'}, ($patterns{'fd_string'}), ($patterns{'dup3_flags'})$/,

	'pipe' => qr/^\[$patterns{'pipefd_with_possible_name'}, $patterns{'pipefd_with_possible_name'}\]$/,
	'socketpair' => qr/^($patterns{'socket_domain'}), ($patterns{'socket_type'}), ($patterns{'socket_proto'}), (\[$patterns{'sockfd_with_possible_name'}, $patterns{'sockfd_with_possible_name'}\])$/,

	'readlink' => qr/$patterns{'proc_pid_exe'}, $patterns{'quoted_string'}, $patterns{'digits_string'}$/,

#	'clone' => qr/^child_stack=$patterns{'hex_string_or_null'}, flags=($patterns{'clone_flags'}), parent_tidptr=$patterns{'hex_string'}, tls=$patterns{'hex_string'}, child_tidptr=$patterns{'hex_string'}$/,
	'clone' => qr/^child_stack=$patterns{'hex_string_or_null'}, flags=($patterns{'clone_flags'})(, .+)?$/,
# clone(child_stack=0x7fc9df076fb0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0x7fc9df0779d0, tls=0x7fc9df077700, child_tidptr=0x7fc9df0779d0) = 9057
# clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f21efcbba10) = 1447033


#	'generic_function_fd' => qr/^$patterns{'fd_or_negative_one_with_possible_path'}, $patterns{'everything_else'}$/,
	'generic_function_fd' => qr/^$patterns{'fd_or_negative_one_with_possible_path'}$patterns{'possible_other_args'}$/,
	'generic_function_dfd_path' => qr/^$patterns{'fd_or_atfdcwd_with_possible_path'}, $patterns{'quoted_string'}, $patterns{'everything_else'}$/,





	'execve' => qr/^$patterns{'execve_path_string'}, $patterns{'execve_argv_string'}, $patterns{'execve_envp_string'}$/,


	'return_fd_path' => qr/^$patterns{'fd_with_possible_path'}$/,
	'return_error' => qr/$patterns{'return_error_string'}$/,

);
#1119840 16:59:55.153682 openat(AT_FDCWD, "/usr/share/locale/locale.alias", O_RDONLY|O_CLOEXEC) = 3</usr/share/locale/locale.alias> <0.000037>
#1120026 17:00:32.779494 openat(5</home/sos/2948400>, "sosreport-testbic1wn2l-2021-05-26-crzdojg", O_RDONLY|O_NOCTTY|O_NONBLOCK|O_NOFOLLOW|O_CLOEXEC|O_DIRECTORY) = 6</home/sos/2948400/sosreport-testbic1wn2l-2021-05-26-crzdojg> <0.000058>
# int openat(int dirfd, const char *pathname, int flags, mode_t mode);

# functions with the first argument being an fd
@generic_fd_functions = (
	"futimens", "flock", 'ftruncate',
	"fchmod", "fchown", "flock", "fstat", "fstatfs",
	"read", "write", "pread", "pwrite", "readv", "writev", "preadv", "pwritev", "preadv2", "pwritev2", "lseek",
	"pread64", "fadvise64",
	"fsync", "fdatasync",
	"ioctl"
);

@generic_dfd_pathname_functions = ( "faccessat", "fchownat", "unlinkat", "fchmodat",
	"utimensat", "futimensat", "mkdirat", "fstatat", "fstatat64",
	"newfstatat",
);

# newfstatat fstatat fsstat64 creat open openat openat2 close fchdir dup dup2 dup3 fcntl unlinkat symlinkat renameat
# fsync ioctl select
#       int symlinkat(const char *target, int newdirfd, const char *linkpath);
@no_parsing_functions = (
	'getpid', 'getuid', 'geteuid', 'getgid', 'getegid',
	'setpgid', 'getpgid', 'chown', 'lchown',
	'futex', 'access', 'stat', 'lstat',
	'brk', 'mmap', 'munmap', 'mprotect',
	'prctl', 'arch_prctl', 'uname', 'prlimit', 'prlimit64', 'set_robust_list', 'set_tid_address',
	'wait4', 'kill', 'exit_group', 'statfs',
	'getrlimit', 'setrlimit', 'getxattr', 'lgetxattr',
	'mremap', 'madvise',
	'clock_gettime', 'clock_getres',
	'sched_yield', 'sched_getaffinity', 'sched_setaffinity',
	'mkdir', 'rmdir', 'unlink',


	# TODO: gettid
	'gettid',

	'capget', 'capset',


	# TODO:
	'poll', 'select',

	# TODO:  network-related
	'socket', 'connect', 'accept', 'accept4', 'shutdown', 'listen',


	"alarm",
	"bind",
	"chmod",
	"get_mempolicy",
	"getgroups",
	"getpgrp",
	"getppid",
	"getpriority",
	"getrandom",
	"getresgid",
	"getresuid",
	"getrusage",
	"getsid",
	"getsockname",
	"getsockopt",
	"keyctl",
	'mlock',
	"nanosleep",
	"pipe2",
	"ppoll",
	"pselect6",
	"recvfrom",
	"recvmsg",
	"rename",
	'rt_sigaction',
	"rt_sigpending",
	'rt_sigprocmask',
	'rt_sigqueueinfo',
	'rt_sigreturn',
	"rt_sigtimedwait",
	"sched_setscheduler",
	"sched_get_priority_min",
	"sched_get_priority_max",
	"sched_setpriority_min",
	"sched_setpriority_max",
	"sched_setscheduler",
	"semctl",
	"semget",
	"semop",
	"sendmmsg",
	"sendmsg",
	"sendto",
	"setgid",
	"setgroups",
	"setpriority",
	"setregid",
	"setresgid",
	"setresuid",
	"setreuid",
	'setsid',
	"setsockopt",
	"setuid",
	"shmat",
	"shmctl",
	"shmdt",
	"shmget",
	"sigaltstack",
	"sysinfo",
	"tgkill",
	"umask",

);
# TODO: clone execve(cloexec) exit_group select pselect6 pipe

# socket connect poll
#


#printf("generic_function_fd pattern is '^$patterns{'fd_with_possible_path'}, $patterns{'everything_else'}\$'\n");
#printf("generic_function_dfd_path pattern is '^$patterns{'fd_or_atfdcwd_with_possible_path'}, $patterns{'quoted_string'}, $patterns{'everything_else'}\$'\n");

while (<>) {
	my ($pid, $timestamp, $op, $args, $ret, $elapsed);
	my ($dfd, $dfd_path, $other_args);

	chomp;
	my $line = $_;
	my @matches;

	if ($line eq "" or substr($line, 0, 1) eq "#") { next; }


#	qr/^$patterns{'possible_pid_string'}$patterns{'possible_timestamp_string'}$patterns{'op_string'}\($patterns{'op_args_string'} <unfinished ...>$/,
#	if (@matches = $line =~ $regexes{'unfinished'}) {
#	if (($pid, $timestamp, $op, my $op_args) = $line =~ $regexes{'unfinished'}) {
	if (($pid, $timestamp, $op, my $op_args) = $line =~ $regexes{'unfinished'}) {
		if ($config{'debug'} >= 2) {
			printf("syscall unfinished: %s\n", $line);

			printf("pid: %d\n", get_match_val($pid));
			printf("timestamp: %s\n", get_match_val($timestamp));
			printf("op: %s\n", $op);
			printf("op args: %s\n", get_match_val($op_args));
		}
		my $save_line = sprintf("%s %s%s(%s",
			$pid, defined($timestamp) ? $timestamp . " " : "",
			$op, defined($op_args) ? $op_args : "");

		store_unfinished($pid, $save_line);
		next;
#	} elsif (@matches = $line =~ $regexes{'resumed'}) {
	} elsif (($pid, $timestamp, $op, my $remainder) = $line =~ $regexes{'resumed'}) {
		if ($config{'debug'} >= 2) {
			printf("resumed syscall line: %s\n", $line);

			printf("pid: %d\n", $pid);
			printf("timestamp: %s\n", get_match_val($timestamp));
			printf("op: %s\n", $op);
			printf("remainder of line: %s\n", get_match_val($remainder));
		}
		my $stored_line = retrieve_unfinished($pid);
		if ($stored_line eq "") {
			printf("couldn't find an unfinished line for pid %d to match: %s\n", $pid, $line) if ($config{'debug'} >= 2);
		} else {
			$line = $stored_line . trim($remainder);
			printf("attached stored line '%s', resulting in completed line '%s'\n",
				$stored_line, $line) if ($config{'debug'} >= 2);
		}
	}

printf("\n") if ($config{'debug'} >= 1);
printf("parsing %s\n", $line) if ($config{'debug'} >= 1);
my $orig_line = $line;

# qr/^$patterns{'possible_pid_string'}$patterns{'possible_timestamp_string'}$patterns{'op_string'}\($patterns{'op_args_string'}\)$patterns{'ret_string'}$patterns{'possible_elapsed_string'}$/



	if ( ($pid, $timestamp, $op, $args, $ret, $elapsed) = $line =~ $regexes{'op'}) {
		my $rebuild_line = false;

		$args = trim($args);

		if ($config{'debug'} >= 1) {
			printf("%12s - %s\n", "pid", get_match_val($pid));
			printf("%12s - %s\n", "timestamp", get_match_val($timestamp));
			printf("%12s - %s\n", "op", get_match_val($op));
			printf("%12s - %s\n", "args", get_match_val($args));
			printf("%12s - %s\n", "ret", get_match_val($ret));
			printf("%12s - %s\n", "elapsed", get_match_val($elapsed));
		}
#		printf("match: op is %s, args: %s, ret: %s, error or path: '%s', elapsed: %s\n", $op, $args, $ret, $error_or_path, $elapsed);

		if ($op eq "getcwd") {
			printf("matched the getcwd pattern\n") if ($config{'debug'} >= 1);
			if (my ($path) = $args =~ $regexes{'getcwd'}) {
				set_cwd($pid, $path) if (!ret_is_error($ret));
			} else {
				printf("getcwd op, but didn't match the re\n");
			}
		} elsif ($op eq "fstatZZZZ") {
			if (my @m2 = $args =~ $regexes{'fstat'}) {
				printf("matched the fstat pattern\n") if ($config{'debug'} >= 1);
				if ($config{'debug'} >= 2) {
					printf("%16s - %s\n", "fd", get_match_val($m2[0]));
					printf("%16s - %s\n", "fd_path", get_match_val($m2[1]));
					printf("%16s - %s\n", "statbuf", get_match_val($m2[2]));
					# TODO - parse the return code
				}
			} else {
				printf("fstat, but didn't match the re\n");
			}
		} elsif ($op eq "newfstatatZZZ" or $op eq "fstatatZZZ" or $op eq "fstatat64ZZZ") {
			if (my @m2 = $args =~ $regexes{'newfstatat'}) {
printf("matched the fstatat pattern\n");

			if ($config{'debug'} >= 1) {
				printf("%16s - %s\n", "dfd", get_match_val($m2[0]));
				printf("%16s - %s\n", "dfd_path", get_match_val($m2[1]));
				printf("%16s - %s\n", "pathname", get_match_val($m2[2]));
				printf("%16s - %s\n", "statbuf", get_match_val($m2[3]));
				printf("%16s - %s\n", "fstatat_flags", get_match_val($m2[4]));
			}
	# TODO - parse the return code
			} else { printf("newfstatat, but didn't match the re\n"); }

		} elsif ($op eq "creat") {
			# essentially calls open with O_CREAT|O_WRONLY|O_TRUNC
			if (my ($pathname, $open_mode) = $args =~ $regexes{'creat'}) {
				printf("matched 'creat' regex\n") if ($config{'debug'} >= 1);
				if ($config{'debug'} >= 2) {
					printf("%16s - %s\n", "pathname", get_match_val($pathname));
					printf("%16s - %s\n", "open mode", get_match_val($open_mode));
				}
				if (!ret_is_error($ret) and my ($fd, $fd_path) = $ret =~ $regexes{'return_fd_path'}) {
					if (defined($fd_path)) {
						store_fd_name($pid, $fd, $fd_path);
					} else {
						store_fd_name($pid, $fd, $pathname);
						$ret = sprintf("%d<%s>", $fd, $pathname);
						$rebuild_line = true;
					}
				}
			} else {
				printf("creat, but didn't match the re\n");
			}

		} elsif ($op eq "open") {
			if (my ($pathname, $open_flags, $open_mode) = $args =~ $regexes{'open'}) {
					printf("matched 'open' regex\n") if ($config{'debug'} >= 1);
				if ($config{'debug'} >= 2) {
					printf("%16s - %s\n", "pathname", get_match_val($pathname));
					printf("%16s - %s\n", "open flags", get_match_val($open_flags));
					printf("%16s - %s\n", "open mode", get_match_val($open_mode));
				}
				if (!ret_is_error($ret) and my ($fd, $fd_path) = $ret =~ $regexes{'return_fd_path'}) {
					if ($config{'debug'} >= 2) {
						printf("  return fd: %d\n", get_match_val($fd));
						printf("  return fd path: %s\n", get_match_val($fd_path));
					}
					if (defined($fd_path)) {
						store_fd_name($pid, $fd, $fd_path);
					} else {
						store_fd_name($pid, $fd, $pathname);
						$ret = sprintf("%d<%s>", $fd, $pathname);
						$rebuild_line = true;
if (0) {
						$line = sprintf("%s%s%s(%s) = %s%s",
							(defined($pid) ? $pid . " " : ""),
							(defined($timestamp) ? $timestamp . " " : ""),
							$op, $args, $ret,
							(defined($elapsed) ? " " . $elapsed : "")
						);
}
					}
				} # otherwise, error or couldn't parse return string
			} else {
				printf("open, but didn't match the re for args '%s'\n", $args);
			}
		} elsif ($op eq "openat") {
			if (my ($dfd, $dfd_path, $pathname, $open_flags, $open_mode) = $args =~ $regexes{'openat'}) {
				my $rebuild_args = false;

				printf("matched 'openat' regex\n") if ($config{'debug'} >= 1);
				if ($config{'debug'} >= 2) {
					printf("%16s - %s\n", "dfd", get_match_val($dfd));
					printf("%16s - %s\n", "dfd_path", get_match_val($dfd_path));
					printf("%16s - %s\n", "pathname", get_match_val($pathname));
					printf("%16s - %s\n", "open flags", get_match_val($open_flags));
					printf("%16s - %s\n", "open mode", get_match_val($open_mode));
				}
				if (!defined($dfd_path)) {
					$dfd_path = get_fd_path($pid, $dfd);
					$rebuild_args = true if ($dfd_path ne "");
				}
				if (!ret_is_error($ret) and my ($fd, $fd_path) = $ret =~ $regexes{'return_fd_path'}) {
					if ($config{'debug'} >= 2) {
						printf("  return fd: %d\n", get_match_val($fd));
						printf("  return fd path: %s\n", get_match_val($fd_path));
					}
#					$fd_path = get_atpath($pid, $dfd, $pathname) if (!defined($fd_path));
					if (!defined($fd_path)) {
						$fd_path = get_atpath($pid, $dfd, $pathname);
						$ret = sprintf("%d<%s>", $fd, $fd_path);
						$rebuild_line = true;
					}
					store_fd_name($pid, $fd, $fd_path);
					if ($dfd eq "AT_FDCWD" and $pathname eq "." and $fd_path ne "") {
						printf("derived CWD from openat(AT_FDCWD, \".\"...): '%s'\n", $fd_path) if ($config{'debug'} >= 1);
	  					set_cwd($pid, $fd_path);
					}
				}
				if ($rebuild_args) {
					$args = sprintf("%s%s, \"%s\", %s%s",
						$dfd,
						(($dfd_path ne "") ? "<" . $dfd_path . ">" : ""),
						$pathname, $open_flags,
						(defined($open_mode) ? ", " . $open_mode : ""));
					$rebuild_line = true;
				}
			} else {
				printf("openat, but didn't match the re\n");
			}
		} elsif ($op eq "openat2") {
			if (my ($dfd, $dfd_path, $pathname, $open_flags, $open_mode) = $args =~ $regexes{'openat2'}) {
#       int openat2(int dirfd, const char *pathname,
#                   struct open_how *how, size_t size);

if (0) {
printf("matched 'openat2' regex\n");
	printf("%16s - %s\n", "dfd", get_match_val($dfd));
	printf("%16s - %s\n", "dfd_path", get_match_val($dfd_path));
	printf("%16s - %s\n", "pathname", get_match_val($pathname));
	printf("%16s - %s\n", "open flags", get_match_val($open_flags));
	printf("%16s - %s\n", "open mode", get_match_val($open_mode));
}
	# TODO - parse the return code


			} else {
				printf("openat2, but didn't match the re\n");
			}
		} elsif ($op eq "close") {
			if (my ($fd, $fd_path) = $args =~ $regexes{'close'}) {
				printf("matched 'close' regex\n") if ($config{'debug'} >= 1);
				if ($config{'debug'} >= 2) {
					printf("%16s - %s\n", "fd", get_match_val($fd));
					printf("%16s - %s\n", "fd_path", get_match_val($fd_path));
				}
				if (!defined($fd_path)) {
					$fd_path = get_fd_path($pid, $fd);
					$args = sprintf("%d<%s>", $fd, $fd_path) if ($fd_path ne "");
					$rebuild_line = true;
				}
			} else { printf("close but didn't match the re\n"); }
		} elsif ($op eq "chdir") {
			if (my ($path) = $args =~ $regexes{'chdir'}) {
				set_cwd($pid, $path) if (!ret_is_error($ret));
			} else { printf("chdir, but didn't match the re\n"); }
		} elsif ($op eq "fchdir") {
			if (my ($fd, $fd_path) = $args =~ $regexes{'fchdir'}) {
				$fd_path = get_fd_path($pid, $fd) if (!defined($fd_path));
				set_cwd($pid, $fd_path) if ($fd_path ne "" && !ret_is_error($ret));
			} else {printf("fchdir but didn't match the re\n"); }
		} elsif ($op eq "getdents" or $op eq "getdents64") {
			if (($dfd, $dfd_path, $other_args) = $args =~ $regexes{'generic_function_fd'}) {
				printf("matched 'getdents' regex\n") if ($config{'debug'} >= 1);

				if ($config{'debug'} >= 2) {
					printf("%16s - %s\n", "dfd", get_match_val($dfd));
					printf("%16s - %s\n", "dfd_path", get_match_val($dfd_path));
					printf("%16s - %s\n", "other args", get_match_val($other_args));
				}

				my $current_mapping = get_fd_path($pid, $dfd);
				if (defined($dfd_path)) {
					store_fd_name($pid, $dfd, $dfd_path) if ($current_mapping eq "");
				} else {
					if ($current_mapping ne "") {
						$args = sprintf("%s<%s>%s",
							$dfd, $current_mapping,
							(defined($other_args) ? ", " . $other_args : ""));
						$rebuild_line = true;
#						$line = sprintf("%s%s%s(%s) = %s%s",
#							(defined($pid) ? $pid . " " : ""),
#							(defined($timestamp) ? $timestamp . " " : ""),
#							$op, $args, $ret,
#							(defined($elapsed) ? " " . $elapsed : "")
#						);
					}
				}
			}
		} elsif ($op eq "fcntl") {
			my $rebuild_args = false;

			printf("fcntl regex\n") if ($config{'debug'} >= 1);
			if (my ($fd, $fd_path, $fcntl_cmd, $other_args) = $args =~ $regexes{'fcntl'}) {

				if ($config{'debug'} >= 2) {
					printf("fd: %d\n", $fd);
					printf("fd_path: %s\n", get_match_val($fd_path));
					printf("fcntl_cmd: %s\n", $fcntl_cmd);
					printf("other args: %s\n", get_match_val($other_args));
				}

				if (!defined($fd_path)) {
					$fd_path = get_fd_path($pid, $fd);
					$rebuild_args = true if ($fd_path ne "");
				}

				if ($fcntl_cmd eq "F_DUPFD" or $fcntl_cmd eq "F_DUPFD_CLOEXEC") {
					if (!ret_is_error($ret) and my ($ret_fd, $ret_path) = $ret =~ $regexes{'return_fd_path'}) {
						if (!defined($ret_path) and $fd_path ne "") {
#							$ret_path = $fd_path;
							store_fd_name($pid, $ret_fd, $fd_path);
							$ret = sprintf("%d<%s>", $ret_fd, $fd_path);
							$rebuild_line = true;
						} else {
						}
					} else {
					}
				} elsif (grep { $_ eq $fcntl_cmd } ( "F_GETLK", "F_SETLK", "F_SETLKW", "F_OFD_GETLK", "F_OFD_SETLK", "F_OFD_SETLKW" )) {
				} elsif (grep { $_ eq $fcntl_cmd } ( "F_GETFL", "F_SETFL", "F_GETFD", "F_SETFD")) {
				} elsif (grep { $_ eq $fcntl_cmd } ( "F_GETPIPE_SZ", "F_SETPIPE_SZ")) {
				} else {
					printf("fcntl cmd didn't match anything: '%s'\n", $fcntl_cmd);
				}
				if ($rebuild_args) {
					$args = sprintf("%d<%s>, %s%s",
						$fd, $fd_path, $fcntl_cmd,
						(defined($other_args) ? ", " . $other_args : ""));
					$rebuild_line = true;
				}
			}
		} elsif ($op eq "mmap") {
			if (my ($addr, $length, $prot, $flags, $fd, $fd_path, $offset) = $args =~ $regexes{'mmap'}) {


#92997 18:12:17.090315 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f3fd8f4f000 <0.000019>
#92997 18:12:17.091793 mmap(NULL, 46782, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f3fd8f43000 <0.000019>


				if (!defined($fd_path) and $fd >= 0) {
					$fd_path = get_fd_path($pid, $fd);

					if ($fd_path ne "") {
						$args = sprintf("%s, %s, %s, %s, %s%s, %s",
							$addr, $length, $prot, $flags, $fd,
							"<" . $fd_path . ">", $offset);
						$rebuild_line = true;
					}
				}
#	92997 18:12:17.092289 mmap(NULL, 3985920, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f3fd8961000 <0.000018>
#       void *mmap(void *addr, size_t length, int prot, int flags,
#                  int fd, off_t offset);
#       int munmap(void *addr, size_t length);
#			(), (), (), (), #####, ()

#			qr/^([^,]+), ([^,]+), ([^,]+), ([^,]+), 
#			([^,]+), ([^,]+),

			} else { printf("mmap, but didn't match the re: '%s'\n", $regexes{'mmap'}); }
		} elsif ($op eq "dup") {
			if (my ($fd, $fd_path) = $args =~ $regexes{'dup'}) {
				my $rebuild_args = false;

				if (!defined($fd_path)) {
					$fd_path = get_fd_path($pid, $fd);
					$rebuild_args = true if ($fd_path ne "");
				}
				if ($rebuild_args) {
					$args = sprintf("%d<%s>",
						$fd, $fd_path);
					$rebuild_line = true;
				}

				if (!ret_is_error($ret) and my ($ret_fd, $ret_path) = $ret =~ $regexes{'return_fd_path'}) {
					if (!defined($ret_path) and $fd_path ne "") {
						store_fd_name($pid, $ret_fd, $fd_path);
						$ret = sprintf("%d<%s>", $ret_fd, $fd_path);
						$rebuild_line = true;
					} else {}
				} else {}
			}
		} elsif ($op eq "dup2") {
			if (my ($fd, $fd_path, $new_fd) = $args =~ $regexes{'dup2'}) {
				my $rebuild_args = false;

				if (!defined($fd_path)) {
					$fd_path = get_fd_path($pid, $fd);
					$rebuild_args = true if ($fd_path ne "");
				}
				if ($rebuild_args) {
					$args = sprintf("%d<%s>, %s",
						$fd, $fd_path, $new_fd);
					$rebuild_line = true;
				}

				if (!ret_is_error($ret) and my ($ret_fd, $ret_path) = $ret =~ $regexes{'return_fd_path'}) {
					if (!defined($ret_path) and $fd_path ne "") {
						store_fd_name($pid, $ret_fd, $fd_path);
						$ret = sprintf("%d<%s>", $ret_fd, $fd_path);
						$rebuild_line = true;
					} else {}
				} else {}
			}
		} elsif ($op eq "dup3") { # int dup3(int oldfd, int newfd, int flags);
			if (my ($fd, $fd_path, $new_fd, $flags) = $args =~ $regexes{'dup3'}) {
				my $rebuild_args = false;

				if (!defined($fd_path)) {
					$fd_path = get_fd_path($pid, $fd);
					$rebuild_args = true if ($fd_path ne "");
				}
				if ($rebuild_args) {
					$args = sprintf("%d<%s>, %d, %s", $fd, $fd_path, $new_fd, $flags);
					$rebuild_line = true;
				}
				if (!ret_is_error($ret) and my ($ret_fd, $ret_path) = $ret =~ $regexes{'return_fd_path'}) {
					if (!defined($ret_path) and $fd_path ne "") {
						store_fd_name($pid, $ret_fd, $fd_path);
						$ret = sprintf("%d<%s>", $ret_fd, $fd_path);
						$rebuild_line = true;
					} else {}
					if ($flags =~ /O_CLOEXEC/) {
						store_cloexec_fd($pid, $new_fd);
					}
				}
			}
		} elsif ($op eq "pipe") {
			printf("matched pipe\n") if ($config{'debug'} >= 1);
			if (my ($fd0, $fd0_name, $fd1, $fd1_name) = $args =~ $regexes{'pipe'}) {
				my $rebuild_args = false;

				my $pid_string = (defined($pid) && $pid ne -1) ? sprintf("pid_%d_", $pid) : "";


				if (!defined($fd0_name)) {
					$fd0_name = sprintf("%spipe_%d-%d_in", $pid_string, $fd0, $fd1);
					$rebuild_args = true;
				}
				if (!defined($fd1_name)) {
					$fd1_name = sprintf("%spipe_%d-%d_out", $pid_string, $fd0, $fd1);
					$rebuild_args = true;
				}
				store_fd_name($pid, $fd0, $fd0_name);
				store_fd_name($pid, $fd1, $fd1_name);
				if ($rebuild_args) {
					$args = sprintf("[%d<%s>, %d<%s>]",
						$fd0, $fd0_name, $fd1, $fd1_name);
					$rebuild_line = true;
				}
			} else { printf("didn't match pipe regex: %s\n", $regexes{'pipe'}); };
		} elsif ($op eq "socketpair") {
			printf("matched socketpair\n") if ($config{'debug'} >= 1);
			if (my ($af_name, $sock_type, $sock_proto, $fd0, $fd0_name, $fd1, $fd1_name) = $args =~ $regexes{'socketpair'}) {
				my $rebuild_args = false;

				my $pid_string = (defined($pid) && $pid ne -1) ? sprintf("pid_%d_", $pid) : "";

if (0) { # TODO - fix parsing the socket strings
				if (!defined($fd0_name)) {
					$fd0_name = sprintf("%ssocket_%d-%d_in", $pid_string, $fd0, $fd1);
					$rebuild_args = true;
				}
				if (!defined($fd1_name)) {
					$fd1_name = sprintf("%ssocket_%d-%d_out", $pid_string, $fd0, $fd1);
					$rebuild_args = true;
				}
				store_fd_name($pid, $fd0, $fd0_name);
				store_fd_name($pid, $fd1, $fd1_name);
				if ($rebuild_args) {
					$args = sprintf("[%d<%s>, %d<%s>]",
						$fd0, $fd0_name, $fd1, $fd1_name);
					$rebuild_line = true;
				}
}
			} else { printf("didn't match socketpair regex: %s\n", $regexes{'socketpair'}); };
		} elsif ($op eq 'readlink') {
			if ($config{'show_execnames'} && !ret_is_error($ret) && (my ($proc_pid, $link_target) = $args =~ $regexes{'readlink'})) {
				$proc_pid = $pid if ($proc_pid eq 'self');
				printf("found a readlink for pid " . $proc_pid . " to %s\n", $link_target) if ($config{'debug'} >= 2);

				my $current_execname = get_execname($proc_pid);
				printf("pid %d - current execname: %s, execname from readlink: %s\n", $proc_pid, $current_execname, basename($link_target)) if ($config{'debug'} >= 2);

				if ($current_execname eq "") {
					printf("setting execname for pid %d to '%s'\n", $proc_pid, basename($link_target)) if ($config{'debug'} >= 1);
				}

				set_execname($proc_pid, basename($link_target)) if ($current_execname eq "");
			}
		} elsif ($op eq "clone") {
			# if CLONE_FILES is set, the two processes SHARE fd table -- not sure how to implement that
			# if execve is later called, the fd table is duplicated, and no longer shared
#printf("clone args *%s*\n", $args);
			if (my ($flags) = $args =~ $regexes{'clone'}) {
				printf("clone flags: %s\n", $flags) if ($config{'debug'} >= 1);

				if (!ret_is_error($ret)) {
					if ($flags =~ /CLONE_FILES/) {
						store_shared_fd_table_mapping($ret, $pid);
					} else {
						inherit_fd_table($ret, $pid);
					}
					set_execname($ret, get_execname($pid));
				}
			} else { printf("clone didn't match regex\n"); }

		} elsif ($op eq "vfork") {
			if (!ret_is_error($ret)) {
				set_execname($ret, get_execname($pid));
				set_cwd($ret, get_cwd($pid));
				inherit_fd_table($ret, $pid);
			} else { }
		} elsif ($op eq "execve") {
			if (my ($execve_path, $execve_argv, $execve_envp) = $args =~ $regexes{'execve'}) {
				my $execve_name = basename($execve_path);

				set_execname($pid, basename($execve_path));
#				printf("cmd_path: %s\nargv: %s\n", $cmd_path, $argv);
			# TODO - clear the CLOEXEC fds
#["dspmq", "-x", "QM1"], ["

			}

		} elsif ($op eq "exit") { # TODO - what about exit_group?
			clear_fd_table($pid);
		} elsif (is_generic_fd_function($op)) {
			printf("generic fd function: %s\n", $op) if ($config{'debug'} >= 1);

			if (my ($fd, $fd_path, $other_args) = $args =~ $regexes{'generic_function_fd'}) {
				my $rebuild_args = false;

				if (!defined($fd_path)) {
					$fd_path = get_fd_path($pid, $fd);
					$rebuild_args = true if ($fd_path ne "");
				}
				if ($rebuild_args) {
					$args = sprintf("%d%s%s",
						$fd,
						(($fd_path ne "") ? "<" . $fd_path . ">" : ""),
						(defined($other_args) ? ", " . $other_args : ""));
					$rebuild_line = true;
				}
			} else { printf("generic %s(fd...), but '%s' didn't match the regex: %s\n", $op, $args, $regexes{'generic_function_fd'}); }
		} elsif (is_generic_dfd_path_function($op)) {
			printf("generic dfd+path function: %s\n", $op) if ($config{'debug'} >= 1);

			if (my ($dfd, $dfd_path, $path, $other_args) = $args =~ $regexes{'generic_function_dfd_path'}) {
				my $rebuild_args = false;

				if (!defined($dfd_path)) {
					$dfd_path = get_fd_path($pid, $dfd);
					$rebuild_args = true if ($dfd_path ne "");
				}
				if ($rebuild_args) {
					$args = sprintf("%s%s, \"%s\"%s",
						$dfd,
						(($dfd_path ne "") ? "<" . $dfd_path . ">" : ""),
						$path,
						(defined($other_args) ? ", " . $other_args : ""));
					$rebuild_line = true;
				}
# renameat renameat2
# symlinkat

# faccessat dup dup2 dup3
#
# newfstatat fstatat fsstat64 creat open openat openat2 close fchdir faccessat dup dup2 dup3 fcntl utimensat futimens unlinkat symlinkat renameat
# read write pread pwrite lseek readv writev preadv pwritev preadv2 pwritev2 fsync ioctl select
			} else { printf("generic %s(dfd, path...), but '%s' didn't match the regex '%s'\n", $op, $args, $regexes{'generic_function_dfd_path'}); }
		} elsif (do_not_parse_function($op)) {
#			printf("%s\n", $line);

		} else {
printf("matched the main pattern, but didn't find a matching op for '$op'\n");
printf(" full string: %s\n", $line);
		}

		my $execname = $config{'show_execnames'} ? get_execname($pid) : "";
		$rebuild_line = true if (defined($execname) && $execname ne "");

		$line = sprintf("%s%s%s%s(%s) = %s%s",
			(defined($pid) ? $pid . " " : ""),
			((defined($execname) && $execname ne "") ? "(" . $execname . ") " : ""),
			(defined($timestamp) ? $timestamp . " " : ""),
			$op, $args, $ret,
			(defined($elapsed) ? " <" . $elapsed . ">" : "")
		) if ($rebuild_line);
	} elsif (my ($pid, $timestamp, $ret) = $line =~ $regexes{'process_exited'}) {
		if (defined($pid) && $config{'show_execnames'}) {
			my $execname = get_execname($pid);
			$line = sprintf("%d (%s) %s +++ exited with %d +++",
				$pid, $execname,
				(defined($timestamp) ? $timestamp . " " : ""),
				$ret);
		}
	} elsif (($pid, $timestamp, my $signal, my $siginfo) = $line =~ $regexes{'process_signal'}) {
		if (defined($pid) && $config{'show_execnames'}) {
			my $execname = get_execname($pid);
			$line = sprintf("%d (%s) %s --- %s %s ---",
				$pid, $execname,
				(defined($timestamp) ? $timestamp . " " : ""),
				$signal, $siginfo);
		}
	} elsif (($pid, $timestamp, my $partial_line) = $line =~ $regexes{'strace_partial_line'}) {
		if (defined($pid) && $config{'show_execnames'}) {
			my $execname = get_execname($pid);
			$line = sprintf("%d (%s) %s%s",
				$pid, $execname,
				(defined($timestamp) ? $timestamp . " " : ""),
				$partial_line);
		}
	} else {
		printf("didn't match op pattern: %s\n", $line) if ($config{'debug'} >= 1);
	}

	if ($config{'debug'} >= 1) {
		printf("<<<=== %s\n", $orig_line);
		printf("===>>> %s\n", $line);
	} else {
		printf("%s\n", $line);
	}
}
