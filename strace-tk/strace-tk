#!/usr/bin/perl -w

use strict;
use warnings FATAL => 'all';
no warnings 'portable';

#use List::MoreUtils qw/indexes/;
use File::Basename qw/basename/;
use Scalar::Util qw(looks_like_number);
use Getopt::Long;

use Data::Dumper;
#use Devel::StackTrace;
use constant { true => 1, false => 0 };
use Errno qw( :POSIX);

my %config = (
	'debug' => 0,
	'file_positions' => false, # TODO - open(), read(), write(), lseek()
	'expand_getdents' => false, # like strace_getdents awk script -- not very reversible, though
	'output_ls' => false, # gather file & directory information from getdents, *stat*, readlink* calls, and output at end as if from 'ls -alR'
	'combined_stats' => false, # syscall stats (ala '-c')
	'times' => false, # output only start & end times
	'proc_stats' => false, # output per-process syscall stats (rather than combined '-c' stats)
	'progress' => false, # output a progreess indication - only relevant to stats-only, and only if we can seek
	'show_delays' => false, # output relative delay between syscall completion and next syscall start, for each pid
	'pidtree' => false, # gather and output tree of pids

	'output_lines' => true, # output syscall lines; disable if 'stats-only' specified
	'normalize_pids' => true, # no reason not to, but making it a config option, just in case
	'show_execnames' => false,
	'show_elapsed' => true,
	'show_timestamps' => true,
	'adjust_locale' => true, # change the locale of error messages - ### currently, only looks like it converts TO English

	'double_entry' => false, # TODO: output trace entries at both call time and completion time

	'output_pcap' => false, # TODO: output strace entries as syslog entries in a packet capture (implies 'double-entry')
	'output_file' => '', # TODO: name of the file to which output will be written

);

sub usage {
	printf "usage: %s [options] [input_file]\n", $0;
	printf "\toptions:\n";
	printf "\t\t--execnames|--show_execnames|--show-execnames - output names of the executable along with the pid, whenever possible (default: off)\n";
	printf "\t\t--pidtree - output a tree of the process parentage (default: off; re-suppress with 'nopidtree')\n";

	printf "\t\t--output_lines|--output-lines - output the trace lines (default: on; suppress with --nooutput_lines or --stats-only)\n";
	printf "\t\t--stats - output combined stats for all pids (default: off)\n";
	printf "\t\t--proc_stats - output per-process stats for each pid (default: off)\n";
	printf "\t\t--all_stats - enable both 'stats' and 'proc_stats' (default: off)\n";
	printf "\t\t--stats-only - only output stats, not the trace lines (default: off)\n";

	printf "\t\t--elapsed|--show_elapsed|--show-elapsed - output elapsed time for syscalls, whenever possible (default: on; suppress with 'noelapsed')\n";
	printf "\t\t--time|--timestamp - output timestamps for strace entries (default: on; suppress with 'notime' or 'notimestamp)\n";

	printf "\t\t--delays|--deltas - output time between completion of a syscall and start of the next syscall when possible (default: off)\n";
	printf "\t\t\t(requires that the input trace includes both timestamps and elapsed times)\n";

	printf "\n";
	printf "\t\t--file-positions - track and output file positions for fd operations (open, read, write, lseek, etc) - NOT IMPLEMENTED\n";
	printf "\t\t--expand-getdents - pretty-print getdents results (irreversable) - NOT IMPLEMENTED\n";
	printf "\t\t--output-ls - track directory contents and output directory listings at exit - NOT IMPLEMENTED\n";
	printf "\t\t--adjust_locale - change the locale of error messages - PARTIALLY IMPLEMENTED - only changes TO English\n";

	printf "\t\t--double_entry|double-entry - output trace entries at both call time and completion time - NOT IMPLEMENTED\n";
	printf "\t\t--output_pcap|--output-pcap - output strace entries as syslog entries in a packet capture (implies 'double-entry') - NOT IMPLEMENTED\n";

	printf "\t\t-v|--debug|--verbose - increase debugging level\n";

}

GetOptions(
	'debug|verbose|v+' => \$config{'debug'},
	'execnames|e|show_execnames|show-execnames' => sub { $config{'show_execnames'} = true },
#	'file_positions|fpos' => sub { $config{'file_positions'} = true }, # TODO
#	'expand_getdents' => sub { $config{'expand_getdents'} = true }, # TODO
#	'output_ls' => sub { $config{'output_ls'} = true }, # TODO

	'output_lines|output-lines' => sub { $config{'output_lines'} = true; },
	'nooutput_lines|nooutput-lines' => sub { $config{'output_lines'} = false; },

	'times' => sub {
		$config{'times'} = true;
		$config{'output_lines'} = false;
		$config{'show_elapsed'} = false;
		$config{'show_timestamps'} = false;
		$config{'combined_stats'} = false;
	},

	'stats' => sub { $config{'combined_stats'} = true; },
	'proc_stats|proc-stats' => sub { $config{'proc_stats'} = true },

	'stats_only|stats-only|only_stats|only-stats' => sub { $config{'output_lines'} = false; },
	'progress' => sub { $config{'progress'} = true; $config{'output_lines'} = false; },
	'all_stats|all-stats' => sub { $config{'proc_stats'} = true; $config{'combined_stats'} = true; },

	'delay|delays|deltas' => sub { $config{'show_delays'} = true }, # TODO

	'adjust_locale' => sub { $config{'adjust_locale'} = true }, # change the locale of error messages

	'pidtree' => sub { $config{'pidtree'} = true },
	'nopidtree' => sub { $config{'pidtree'} = false },

	'elapsed|show_elapsed|show-elapsed' => sub { $config{'show_elapsed'} = true },
	'noelapsed' => sub { $config{'show_elapsed'} = false },

	'time|timestamp|timestamps' => sub { $config{'show_timestamps'} = true },
	'notime|notimestamp|notimestamps' => sub { $config{'show_timestamps'} = false },

	'double_entry|double-entry' => sub { $config{'double_entry'} = true },
	'output_pcap|output-pcap' => sub { $config{'output_pcap'} = true },

	'help|h' => sub {
		usage();
		exit();
	},
);

if ($config{'debug'} >= 1) {
	printf("config{'debug'}: %d\n", $config{'debug'});
	printf("config{'show_execnames'}: $config{'show_execnames'}\n");
}

if ($config{'output_lines'} == false) { # if suppressing normal output, make sure we output at least stats or pidtree
	$config{'combined_stats'} = true if (
		!$config{'proc_stats'} &&
		!$config{'combined_stats'} &&
		!$config{'pidtree'} &&
		!$config{'times'});
}

STDOUT->autoflush(1);

#my %fd_mappings; # map fds per pid
#my %fd_cloexecs; # fds to close on exec, per pid

# if a clone() is done with CLONE_FILES, the processes share an fd table...
# this contains mappings from a pid back to the process holding the actual fd table
# if execve is later called for this pid, the original fd table is duplicated, and this mapping is removed
my %shared_fd_tables;

my %tracking_data = ();

my %patterns;
my %regexes;
my %syscall_functions;
my @generic_fd_functions;
my @generic_dfd_pathname_functions;
my @to_be_implemented;
my @no_parsing_functions;
my @logged_errors;
my %progress_state = (
	'file_size' => 0,
	'last_progress_printed' => -1,
);
my %unknown_syscalls;

sub log_error {
	while (scalar @_) {
		my $str = shift;
#printf "logging error: %s\n", $str;
		push @logged_errors, $str;
	}
}
sub output_errors {
	printf "unrecognized syscalls: %s\n", join(" ", keys(%unknown_syscalls)) if (scalar(keys(%unknown_syscalls)));

	printf "%d errors:\n", scalar(@logged_errors) if scalar @logged_errors;
	my $i = 1;
#	for my $i (0..scalar(@logged_errors)-1) {
#		printf("error %d: %s\n", $i, $logged_errors[$i]);
#	}
	while (scalar @logged_errors) {
		my $str = shift(@logged_errors);
		printf("error %d: %s\n", $i, trim($str)) if defined $str;
#		printf "%s\n", $str;
		$i++;
	}
}
sub dump_backtrace {
#	my $trace = Devel::StackTrace->new;
	printf("\n");
#	print $trace->as_string;
	printf("\n");
}
sub print_pattern {
	my $name = shift;

	printf("%s: %s\n", $name, $patterns{$name});
}
sub trim {
	my $s = shift;
	$s =~ s/^\s+|\s+$//g;
	return $s
}
sub max_string_len {
	my $max_len = 0;
	while (scalar @_) {
		my $str = shift;
		my $this_len = length($str);
		$max_len = $this_len if ($this_len > $max_len);
	}
	return $max_len;
}
sub get_match_val {
	my $str = shift;
	return (defined($str) ? trim($str) : "undefined");
}

sub get_tracked_var {
	my $var = shift;
	my $pid = shift;

	$pid = -1 if (!defined($pid));
	local *_get_tracked_var = sub {
		my $var = shift;
		my $pid = shift;

		return $tracking_data{$pid}{$var} if (defined($tracking_data{$pid}{$var}));
		return "";
	};
	my $result = _get_tracked_var($var, $pid);
	printf("get_tracked_var('%s') for pid %d is " . $result . "\n", $var, $pid) if ($config{'debug'} >= 1);
	return $result;
}
sub set_tracked_var {
	my $var = shift;
	my $pid = shift;
	my $val = shift;

	return if (!defined($val));
	$pid = -1 if (!defined($pid));
	local *_set_tracked_var = sub {
		my $var = shift;
		my $pid = shift;
		my $val = shift;

		$tracking_data{$pid}{$var} = $val;
		return $tracking_data{$pid}{$var};
	};
	my $result = _set_tracked_var($var, $pid, $val);
	printf("set_tracked_var('%s', pid %d) (" . $result . ")\n", $var, $pid) if ($config{'debug'} >= 1);
	return $result;
}

sub get_cwd {
	my $pid = shift;
	$pid = -1 if !defined($pid);
	return $tracking_data{$pid}{'cwd'} if defined $tracking_data{$pid}{'cwd'};
	return "";
	return get_tracked_var('cwd', @_);

#	my $pid = shift;

	$pid = -1 if (!defined($pid));

	local *_get_cwd = sub {
		my $pid = shift;

		return $tracking_data{$pid}{'cwd'} if (defined($tracking_data{$pid}{'cwd'}));
		return "";
	};
	my $result = _get_cwd($pid);
	printf("get_cwd(pid: %s): '%s'\n",
		(($pid > 0) ? $pid : "nopid"), $result) if ($config{'debug'} >= 1);
	return $result;
}
sub set_cwd {
	return if (!defined($2));
	set_tracked_var('cwd', @_);
	return;

	my $pid = shift;
	my $cwd = shift;

	return if (!defined($cwd));
	$pid = -1 if (!defined($pid));

	local *_set_cwd = sub {
		my $pid = shift;
		my $cwd = shift;

		$tracking_data{$pid}{'cwd'} = $cwd;
	};
	_set_cwd($pid, $cwd);
}

sub get_last_sysret {
	return get_tracked_var('last_sysret', @_);
}
sub set_last_sysret {
	return set_tracked_var('last_sysret', @_);
}
sub set_execname {
	return set_tracked_var('execname', @_);

	my $pid = shift;
	my $exe = shift;
#	return if (!$config{'show_execnames'});
	return if (!defined($exe));
	$pid = -1 if (!defined($pid));

	local *_set_execname = sub {
		my $pid = shift;
		my $exe = shift;

		$tracking_data{$pid}{'execname'} = $exe;
		return $tracking_data{$pid}{'execname'};
	};
	my $result = _set_execname($pid, $exe);
	printf("set_execname(%s, %s) (%s)\n", $pid, $exe, $tracking_data{$pid}{'execname'}) if ($config{'debug'} >= 1);
	return $result;
}
sub get_execname {
	my $pid = shift;
	$pid = -1 if !defined($pid);
	return $tracking_data{$pid}{'execname'} if defined $tracking_data{$pid}{'execname'};
	return "";
}

sub get_shared_fd_table_mapping {
	my $pid = shift;

	$pid = -1 if (!defined($pid));
	return $pid if ($pid == -1);

	if (defined($shared_fd_tables{$pid})) {
		# this pid actually shares a table with another pid
		# map to that pid before trying to do anything here
		printf("mapping pid %d to shared fd table of pid %d\n",
			$pid, $shared_fd_tables{$pid}) if ($config{'debug'} >= 1);
		return $shared_fd_tables{$pid};
	}
	return $pid;
}
# store_shared_fd_table_mapping(new_pid, pid_of_table_to_share)
sub store_shared_fd_table_mapping {
	my $new_pid = shift;
	my $target = shift;

	return if (!defined($new_pid) || $new_pid == -1);
	return if (!defined($target) || $target == -1);

	$target = get_shared_fd_table_mapping($target); # is target already sharing?
	$shared_fd_tables{$new_pid} = $target;
}
# copy (not share) fds
sub inherit_fd_table {
	my $new_pid = shift;
	my $orig_pid = shift;

	return if (!defined($new_pid) || $new_pid == -1);
	return if (!defined($orig_pid) || $orig_pid == -1);

	$orig_pid = get_shared_fd_table_mapping($orig_pid);

	my @fds = keys(%{$tracking_data{$orig_pid}{'fd_mappings'}});
	foreach my $fd (@fds) {
		store_fd_name($new_pid, $fd, get_fd_path($orig_pid, $fd));
	}
	printf("copied fd table of pid %d to pid %d\n", $orig_pid, $new_pid) if ($config{'debug'} >= 1);
	# TODO - duplicate cloexec table?
}
sub clear_fd_table { # call when process is exiting
	my $pid = shift;

	$pid = -1 if (!defined($pid));
	undef($tracking_data{$pid}{'fd_mappings'}) if (defined($tracking_data{$pid}{'fd_mappings'}));

	printf("cleared fd table for pid %d\n", $pid) if ($config{'debug'} >= 1);
}
sub dump_fd_mappings {
	my @pids = keys(%tracking_data);
	printf("indexes: %s\n", join(" ", @pids));

	foreach my $pid (@pids) {
		printf("pid %d\n", $pid);

		my @fds = keys(%{$tracking_data{$pid}{'fd_mappings'}});
		foreach my $fd (sort { $a <=> $b} (keys(%{$tracking_data{$pid}{'fd_mappings'}}))) {
			printf("fd: %d - '%s'\n", $fd, $tracking_data{$pid}{'fd_mappings'}{$fd});
		}
	}
}

sub store_cloexec_fd {
	my $pid = shift;
	my $fd = shift;

	$pid = -1 if (!defined($pid));
	$tracking_data{$pid}{'cloexec'}{$fd} = true;
	printf("stored pid %d fd %d CLOEXEC\n", $pid, $fd) if ($config{'debug'} >= 1);
}
sub drop_cloexec_fd {
	my $pid = shift;
	my $fd = shift;

	$pid = -1 if (!defined($pid));
	$pid = get_shared_fd_table_mapping($pid);
	undef($tracking_data{$pid}{'cloexec'}{$fd}) if (defined($tracking_data{$pid}{'cloexec'}{$fd}));
	printf("removed pid %d fd %d CLOEXEC\n", $pid, $fd) if ($config{'debug'} >= 1);
}
sub store_fd_name {
	my $pid = shift;
	my $fd = shift;
	my $path = shift;

	dump_backtrace() if !defined($path);
	$path =~ s/^<|>$//g;

	$pid = -1 if (!defined($pid));
	$pid = get_shared_fd_table_mapping($pid);

	return if ($fd < 0);

	# TODO: track chroot()-relative paths

	$tracking_data{$pid}{'fd_mappings'}{$fd} = $path;
	printf("storing pid: %d fd: %d -> %s\n", $pid, $fd, $path) if ($config{'debug'} >= 1);
}
sub drop_fd_name {
	my $pid = shift;
	my $fd = shift;

	$pid = -1 if (!defined($pid));
	$pid = get_shared_fd_table_mapping($pid);

	undef($tracking_data{$pid}{'fd_mappings'}{$fd}) if (defined($tracking_data{$pid}{'fd_mappings'}{$fd}));
}
sub get_dfd_path {
	my $pid = shift;
	my $dfd = shift;

	local *_get_dfd_path = sub {
		my $pid = shift;
		my $dfd = shift;

		return get_cwd($pid) if ($dfd eq "AT_FDCWD");
		return get_fd_path($pid, $dfd);
	};
	my $result = _get_dfd_path($pid, $dfd);
	printf("get_dfd_path(pid: %s, dfd: %s) -> '%s'\n",
		get_match_val($pid), $dfd, $result) if ($config{'debug'} >= 1);
	return $result;
}
sub get_fd_path {
	my $pid = shift;
	my $fd = shift;

	$pid = -1 if (!defined($pid));
	local *_get_fd_path = sub {
		my $pid = shift;
		my $fd = shift;

		return get_cwd($pid) if ($fd eq "AT_FDCWD");

		$pid = get_shared_fd_table_mapping($pid);

		# TODO: track chroot()-relative paths
		return $tracking_data{$pid}{'fd_mappings'}{$fd} if (defined($tracking_data{$pid}{'fd_mappings'}{$fd}));
		return "";
	};
	my $result = _get_fd_path($pid, $fd);
	printf("get_fd_path(pid: %s, fd: %s) -> '%s'\n",
		get_match_val($pid), $fd, $result) if ($config{'debug'} >= 1);
	return $result;
}
sub cleanup_path {
	my $path = shift;

	my @path_components = split('/', $path);
	my @new_path_components;
	for my $ele (@path_components) {
		if ($ele eq "..") { pop @new_path_components; }
		elsif ($ele eq "") {}
		else { push @new_path_components, $ele; }
	}
	my $new_path = '/' . join '/', @new_path_components;

	return $new_path;
}

sub get_atpath {
	my $pid = shift;
	my $dfd = shift;
	my $path = shift;

	$pid = -1 if (!defined($pid));
	local *_get_atpath = sub {
		my $pid = shift;
		my $dfd = shift;
		my $path = shift;

		# if pathname is absolute, dirfd is ignored
		return $path if (substr($path, 0, 1) eq "/");

 	       # If pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the current working directory of the calling process (like open()).
#		return get_cwd($pid) . "/" . $path if ($dfd eq "AT_FDCWD");
		if ($dfd eq "AT_FDCWD") {
			my $cwd = get_cwd($pid);

			return $cwd if ($cwd ne "" and $path eq ".");
			return cleanup_path($cwd . "/" . $path) if ($cwd ne "");
			return cleanup_path $path;
		}

		# dirfd is not AT_FDCWD and the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the file descriptor dirfd (rather than relative to the current working directory of the calling process, as is done by open() for a relative pathname).

		my $fd_path = get_fd_path($pid, $dfd);
		return $fd_path if ($fd_path ne "" and $path eq ".");
		return cleanup_path($fd_path . "/" . $path) if ($fd_path ne "");

		# return one of these, depending on which we decide we like best
		return "<" . $dfd . ">/" . cleanup_path($path);
#		return cleanup_path($path);
	};

	my $result = _get_atpath($pid, $dfd, $path);
	printf("get_atpath for pid: %s, dfd: '%s', path: '%s' -> '%s'\n",
		get_match_val($pid), $dfd, $path, $result) if ($config{'debug'} >= 1);
	return $result;
}

sub store_unfinished {
	my $pid = shift;
	my $store_line = shift;

	$tracking_data{$pid}{'unfinished'} = $store_line;
}
sub retrieve_unfinished {
	my $pid = shift;
	my $ret = "";

	dump_backtrace() if (!defined($pid));

	if (defined($tracking_data{$pid}{'unfinished'})) {
		$ret = $tracking_data{$pid}{'unfinished'};
		undef($tracking_data{$pid}{'unfinished'});
	}
	return $ret;
}
sub is_generic_fd_function {
	my $syscall = shift;

	if ($config{'debug'} >= 2) {
		foreach my $o (@generic_fd_functions) {
			printf("testing whether '%s' matches '%s'\n", $syscall, $o);
		}
	}
	return (grep { $_ eq $syscall } @generic_fd_functions);
}
sub is_generic_dfd_path_function {
	my $syscall = shift;

	if ($config{'debug'} >= 2) {
		foreach my $o (@generic_dfd_pathname_functions) {
			printf("testing whether '%s' matches '%s'\n", $syscall, $o);
		}
	}
	return (grep { $_ eq $syscall } @generic_dfd_pathname_functions);
}
sub do_not_parse_function {
	my $syscall = shift;
	return (grep { $_ eq $syscall } @no_parsing_functions);
}
sub ret_is_error {
	my $ret = shift;

	if (!defined($ret)) {
		dump_backtrace();
		exit(1);
	}

	return ($ret =~ $regexes{'return_error'});
}
sub ts_to_sec {
	my $ts = shift;
	my $epoch_re = qr/^$patterns{'epoch_time_string'}$patterns{'time_possible_subseconds'}$/;

	return $ts if ($ts =~ $epoch_re);

	my $h = substr($ts, 0, 2) + 0;
	my $m = substr($ts, 3, 2) + 0;
	my $s = substr($ts, 6) + 0;

	return (($h*60)+$m)*60 + $s;
}
sub sec_to_ts {
	my $s = shift;
	my $us = int(($s * 1000000) % 1000000);
	$s = int($s);
	my $m = int($s / 60);
	$s -= (60 * $m);
	my $h = int($m / 60);
	$m -= (60 * $h);

	return sprintf("%02d:%02d:%02d.%06d", $h, $m, $s, $us);
}
sub format_delay {
	my $rel = shift;

	return "" if !defined($rel) || !$config{'show_delays'};
	if (!defined($rel) || $rel eq 'undefined') {dump_backtrace(); exit;}
	return sprintf("+%.6f", trim($rel));
}
sub pid_string_is_alt {
        return 1 if ($_[0] =~ $regexes{'alt_pid'});
	return 0
}

sub pidtree_add_pid {
	my ($pid, $cmd) = @_;

	if (defined $pid || $pid ne "" && !defined $tracking_data{'pid_tree'}{'cpids'}{$pid}) {

		if (!defined($tracking_data{'pid_tree'}{'parents'}{$pid})) {
			$tracking_data{'pid_tree'}{'tlpids'}{$pid} = true;
		}

		$tracking_data{'pid_tree'}{'tree'}{$pid} = ();
		$tracking_data{'pid_tree'}{'cmds'}{$pid} = $cmd;
		@{$tracking_data{'pid_stats'}{'pid'}{$pid}{'cmd_history'}} = ($cmd);
		$tracking_data{'pid_tree'}{'cpids'}{$pid} = true;
	}
}
sub pidtree_new_cmd {
	my ($pid, $cmd) = @_;

	$pid = -1 if !defined $pid;
	$tracking_data{'pid_tree'}{'cmds'}{$pid} = $cmd;
	push @{$tracking_data{'pid_stats'}{'pid'}{$pid}{'cmd_history'}}, $cmd;
}

sub pidtree_add_child {
	my ($ppid, $pid, $cmd) = @_;

	if (!defined($tracking_data{'pid_tree'}{'parents'}{$ppid}) &&
		!defined($tracking_data{'pid_tree'}{'tree'}{$ppid})) {

		$tracking_data{'pid_tree'}{'tlpids'}{$ppid} = true;

		$tracking_data{'pid_tree'}{'cmds'}{$ppid} = $cmd if !defined $tracking_data{'pid_tree'}{'cmds'}{$ppid};
		@{$tracking_data{'pid_stats'}{'pid'}{$ppid}{'cmd_history'}} = ($cmd) if !defined $tracking_data{'pid_stats'}{'pid'}{$ppid}{'cmd_history'}
	}

	$tracking_data{'pid_tree'}{'parents'}{$pid} = $ppid;

	$tracking_data{'pid_tree'}{'tree'}{$ppid}{$pid} = $cmd;

	pidtree_add_pid($pid, $cmd);

#	$tracking_data{'pid_tree'}{'cpids'}{$ppid} = true if (!defined($tracking_data{'pid_tree'}{'cpids'}{$ppid}));
	$tracking_data{'pid_tree'}{'cpids'}{$ppid} = true;

}
# syscalls not to add to stats
our @nostats = (
	'epoll_ctl', 'epoll_wait', 'poll', 'ppoll',
);

sub add_syscall_stats {
	my ($trace_entry) = @_;

	my $pid = ($trace_entry->{'pid'} ne "") ? $trace_entry->{'pid'} : -1;

#printf "add_syscall_stats for pid %d\n", $pid;

	if (!defined $tracking_data{'pid_tree'}{'cpids'}{$pid}) {
#		defined $trace_entry->{'pid'} &&
#		$trace_entry->{'pid'} ne "" &&
#		!defined $tracking_data{'pid_tree'}{'cpids'}{$trace_entry->{'pid'}}) {

		my $cmd = "unknown";

		if (defined $trace_entry->{'this_line_execname'}) {
			$cmd = $trace_entry->{'this_line_execname'};
		} else {
			$cmd = get_execname($pid);
		}
		$cmd = "unknown" if $cmd eq "";

		pidtree_add_pid($pid, $cmd);
	}
	$tracking_data{'pid_stats'}{'pid'}{$pid}{'syscalls'} = {} if !defined($tracking_data{'pid_stats'}{'pid'}{$pid});
	if ($trace_entry->{'timestamp'} ne '') {
		$tracking_data{'pid_stats'}{'pid'}{$pid}{'first_time'} = $trace_entry->{'timestamp'} if !defined $tracking_data{'pid_stats'}{'pid'}{$pid}{'first_time'};
		$tracking_data{'pid_stats'}{'pid'}{$pid}{'last_time'} = $trace_entry->{'timestamp'};
	}
	my $syscall = $trace_entry->{'syscall'};

	return if ($syscall eq "" || (grep $_ eq $syscall, @nostats));

#	if (!defined $tracking_data{'pid_stats'}{'pid'}{$pid}) {

#	$tracking_data{'pid_stats'}{'pid'}{$pid}{'syscalls'} = {} if !defined($tracking_data{'pid_stats'}{'pid'}{$pid});
	my $this_pid_stats = $tracking_data{'pid_stats'}{'pid'}{$pid};

#	if ($trace_entry->{'syscall'} ne "") {
#		$trace_entry->{'syscall'} ne "") {
#	if (!defined $tracking_data{'pid_stats'}{
	if ($syscall ne "") {
		my $elapsed = $trace_entry->{'elapsed'};

		$tracking_data{'pid_stats'}{'pid'}{$pid}{'syscalls'}{$syscall} = {
			'count' => 0,
			'min' => ($elapsed eq '') ? 0 : $elapsed,
			'max' => ($elapsed eq '') ? 0 : $elapsed,
			'errors' => 0,
			'elapsed' => 0,
			'rolling_mean' => 0,
			'rolling_M2' => 0,
		} if !defined $tracking_data{'pid_stats'}{'pid'}{$pid}{'syscalls'}{$syscall};
		my $this_syscall_stats = $tracking_data{'pid_stats'}{'pid'}{$pid}{'syscalls'}{$syscall};

if (0) {
		if (! defined $this_syscall_stats) {
			$this_syscall_stats->{'count'} = 0;
			if ($elapsed ne '') {
				$this_syscall_stats->{'min'} = $elapsed;
				$this_syscall_stats->{'max'} = $elapsed;
			}
		}
}
		$this_syscall_stats->{'count'}++;
		if ($elapsed ne '') {
			$this_syscall_stats->{'min'} = $elapsed if $elapsed < $this_syscall_stats->{'min'};
			$this_syscall_stats->{'max'} = $elapsed if $elapsed > $this_syscall_stats->{'max'};

			$this_syscall_stats->{'elapsed'} += $elapsed;

#			my $old_mean = $this_syscall_stats->{'rolling_mean'};
#			my $new_mean = $old_mean + (

			my $e = int($elapsed * 1000000000);
			my $rm = int($this_syscall_stats->{'rolling_mean'} * 1000000000);
			my $d = $e - $rm;
			$rm += $d / $this_syscall_stats->{'count'};
			my $d2 = $e - $rm;
			my $m2 = ($this_syscall_stats->{'rolling_M2'} * 1000000000);
			$m2 += $d * $d2;

			my $delta = $elapsed - $this_syscall_stats->{'rolling_mean'};
			$this_syscall_stats->{'rolling_mean'} += $delta / $this_syscall_stats->{'count'};
			my $delta2 = $elapsed - $this_syscall_stats->{'rolling_mean'};
#			$this_syscall_stats->{'rolling_M2'} += $delta * ($elapsed - $this_syscall_stats->{'rolling_mean'});
#			$this_syscall_stats->{'rolling_M2'} += $delta * $delta2;

			$this_syscall_stats->{'rolling_M2'} = $m2 / 1000000000;

#	printf "%s - rolling_mean: %.06f, rolling_M2: %.06f\n", $syscall, $this_syscall_stats->{'rolling_mean'}, $this_syscall_stats->{'rolling_M2'};

		}
		$this_syscall_stats->{'errors'}++ if ret_is_error($trace_entry->{'ret'});
	}
}
sub compute_overall_stats {
	my @stats_pids = sort(keys( %{$tracking_data{'pid_stats'}{'pid'}}));

	$tracking_data{'pid_stats'}{'overall'} = {
		'syscalls' => {},
	} if !defined $tracking_data{'pid_stats'}{'overall'};

	my $overall_stats = $tracking_data{'pid_stats'}{'overall'};
#	my $overall_syscall_stats = $tracking_data{'pid_stats'}{'overall'}{'syscalls'};
	my $overall_syscall_stats = $overall_stats->{'syscalls'};

	local *_add_syscall_stat = sub {
		my $these_stats = shift;
		my $syscall = shift;

#printf "these stats:\n";
#print Dumper($these_stats);

	$overall_syscall_stats->{$syscall} = {
		'count' => 0,
		'errors' => 0,
		'elapsed' => 0,
		'min' => 0+'inf',
		'max' => 0,
	} if !defined $overall_syscall_stats->{$syscall};

#		$overall_syscall_stats
#		if (!defined $overall_syscall_stats->{$syscall}) {
#			'count' => 0,
#			'errors' = 0,
#			'elapsed' => 0,
#		};

#		$overall_syscall_stats->{$syscall}{'count'} += $these_stats->{'syscalls'}{$syscall}{'count'};
		$overall_syscall_stats->{$syscall}{'count'} += $these_stats->{'count'};
		$overall_syscall_stats->{$syscall}{'errors'} += $these_stats->{'errors'};
		$overall_syscall_stats->{$syscall}{'elapsed'} += $these_stats->{'elapsed'};
		$overall_syscall_stats->{$syscall}{'max'} = $these_stats->{'max'} if $these_stats->{'max'} > $overall_syscall_stats->{$syscall}{'max'};
		$overall_syscall_stats->{$syscall}{'min'} = $these_stats->{'min'} if $these_stats->{'min'} < $overall_syscall_stats->{$syscall}{'min'};
	};
	local *_summarize_syscall_stat = sub {
		my ($syscall_stats) = @_;

		$syscall_stats->{'mean'} = ($syscall_stats->{'count'}) ? $syscall_stats->{'elapsed'} / $syscall_stats->{'count'} : 0;
	};

	local *_compute_pid_stats = sub {
		my ($pid) = @_;

		my $this_pid_stats = $tracking_data{'pid_stats'}{'pid'}{$pid};

		$this_pid_stats->{'runtime'} = ts_to_sec($this_pid_stats->{'last_time'}) - ts_to_sec($this_pid_stats->{'first_time'})
			if (defined $this_pid_stats->{'first_time'} && defined $this_pid_stats->{'last_time'});

		$this_pid_stats->{'syscall_time'} = 0;
		my @syscalls = keys %{$this_pid_stats->{'syscalls'}};

		foreach my $syscall (@syscalls) {
#			my $this_pid_syscall_stats = $this_pid_syscall_stats->{'syscalls'}{$syscall};
			my $this_pid_syscall_stats = $this_pid_stats->{'syscalls'}{$syscall};

#			printf "adding this op (%s) stats:\n", $syscall;
#			print Dumper($this_pid_syscall_stats);
			$this_pid_stats->{'syscall_time'} += $this_pid_syscall_stats->{'elapsed'};
#			$this_pid_syscall_stats->{'mean'} = ($this_pid_syscall_stats->{'count'}) ? $this_pid_syscall_stats->{'elapsed'} / $this_pid_syscall_stats->{'count'} : 0;
			_summarize_syscall_stat($this_pid_syscall_stats);

			_add_syscall_stat($this_pid_syscall_stats, $syscall);

		}
	};

#			$tracking_data{'pid_stats'}{'overall'}{'syscalls'}
#				$overall_syscall_stats->{$syscall}{'count'} += $this_pid_stats->{'syscalls'}{$syscall}{'count'};
#
#				+= $this_pid_stats->{'syscalls'}{$syscall}{'
#				tracking_data{'pid_stats'}{'overall'}{'syscalls'}

	# determine mean for each op for each pid
	# count total syscall time for a pid
#	printf "have stats for %d pids\n", scalar @stats_pids;
	foreach my $pid (@stats_pids) {
		_compute_pid_stats($pid);

#		tracking_data{'pid_stats'}{
	}

	my @syscalls = sort(keys(%{$tracking_data{'pid_stats'}{'overall'}{'syscalls'}}));
	foreach my $syscall (@syscalls) {
#		printf "calculating ovarall stats for syscall %s\n", $syscall;
		_summarize_syscall_stat($tracking_data{'pid_stats'}{'overall'}{'syscalls'}{$syscall});

	}

	# total number of syscalls, errors, time for each op for all pids
	# count total syscall time for all pids

#	if ($config{'proc_stats'}) {
#		printf "per-pid stats\n";
#		print Dumper($tracking_data{'pid_stats'}{'pid'});
#	}

#	if ($config{'combined_stats'}) {
#		printf "overall stats\n";
#		print Dumper($tracking_data{'pid_stats'}{'overall'});
#	}
}

sub output_stats {
	my (%stats) = @_;

	my %syscall_stats = %{$stats{'syscalls'}};
#	my @syscalls = sort(keys(%syscall_stats));
	my @syscalls = sort {$syscall_stats{$a}{'elapsed'} <=> $syscall_stats{$b}{'elapsed'}} keys(%syscall_stats);

	my $longest_syscall_name_len = max_string_len(@syscalls, "syscall");
	printf "%*s   %10s   %6s   %10s   %10s   %10s  %5s   %6s\n", $longest_syscall_name_len, "syscall", "total", "count", "min", "max", "mean", "sd", "errors";

	my $total_elapsed = 0;
#	foreach my $syscall (@syscalls) {
	foreach my $syscall (@syscalls) {
		my %this_syscall_stats = %{$syscall_stats{$syscall}};

		printf "%*s   %10.6f   %6d   %10.6f   %10.6f   %10.6f  %5.03f   %6d\n",
			$longest_syscall_name_len, $syscall, $this_syscall_stats{'elapsed'}, $this_syscall_stats{'count'},
			$this_syscall_stats{'min'}, $this_syscall_stats{'max'},
			$this_syscall_stats{'mean'}, $this_syscall_stats{'rolling_M2'} ? $this_syscall_stats{'rolling_M2'} : 0,
			$this_syscall_stats{'errors'};
if (0) {
if ($this_syscall_stats{'rolling_mean'}) {
	printf "                   rolling mean: %10.6f\n", $this_syscall_stats{'rolling_mean'};
	printf "                   rolling M2 %10.6f\n", $this_syscall_stats{'rolling_M2'};
}
}
		$total_elapsed += $this_syscall_stats{'elapsed'};
	}
	printf "%*s   %10.6f\n", $longest_syscall_name_len, "total", $total_elapsed;
}

sub output_overall_stats {
	printf "***** overall stats *****\n";
	output_stats(%{$tracking_data{'pid_stats'}{'overall'}});
}
sub output_pid_stats {
	my ($pid) = $_[0];
	my $this_pid_stats = $tracking_data{'pid_stats'}{'pid'}{$pid};
	return if !defined $this_pid_stats;

	return if (!defined $this_pid_stats->{'first_time'} || !defined $this_pid_stats->{'last_time'});

	my $cmd_history_str = "";
	if (defined $tracking_data{'pid_stats'}{'pid'}{$pid}{'cmd_history'}) {
#		my @cmd_history = @{$tracking_data{'pid_tree'}{'cmd_history'}{$pid}};
		my @cmd_history = @{$tracking_data{'pid_stats'}{'pid'}{$pid}{'cmd_history'}};
		$cmd_history_str = (scalar @cmd_history > 0) ? join(",", @cmd_history) . " " : "";
	}

	printf "***** pid %d %s*****\n", $pid, $cmd_history_str;

	printf "first time: %s\n", $this_pid_stats->{'first_time'};
	printf "last time:  %s\n", $this_pid_stats->{'last_time'};
	printf "syscall time: %.6f\n", $this_pid_stats->{'syscall_time'};
	printf "runtime:    %.6f\n", $this_pid_stats->{'runtime'};
	output_stats(%{$this_pid_stats});
}

sub output_per_pid_stats {
	printf "***** per-pid stats *****\n";
	my @pids = sort(keys(%{$tracking_data{'pid_stats'}{'pid'}}));

	foreach my $pid (@pids) {
		output_pid_stats($pid);
		printf "\n";
	}
}

sub defined_or_default {
	my ($val, $default) = @_;
	$val = $default if !defined $val;
	return $val;
}

sub err_name_to_num {
	my $err_name = shift;
	return eval("$err_name");
}
sub err_num_to_str {
	my $err_num = shift;
	$! = $err_num;
	my $err_str = sprintf("%s", $!);
	$! = 0;
	return $err_str;
}
sub err_name_to_str {
        my $err_name = shift;
	my $err_num = err_name_to_num($err_name);
	return err_num_to_str($err_num);
}

sub change_err_locale {
	my $ret = shift;

	if ((my $err_name, my $str) = $ret =~ $regexes{'extract_err_name'}) {
		$ret = sprintf("-1 %s (%s)", $err_name, err_name_to_str($err_name));
	}
	return $ret;
}

sub reconstruct_call_line {
	my ($trace_entry) = @_;

	$trace_entry->{'pid'} = -1 if !defined $trace_entry->{'pid'};
	$trace_entry->{'this_line_execname'} = "" if !defined $trace_entry->{'pid'};
	$trace_entry->{'timestamp'} = "" if ! defined $trace_entry->{'timestamp'};
	$trace_entry->{'delay'} = "" if ! defined $trace_entry->{'delay'};
	$trace_entry->{'syscall'} = "" if ! defined $trace_entry->{'syscall'};
	$trace_entry->{'args'} = "" if ! defined $trace_entry->{'args'};
	$trace_entry->{'msg'} = "" if ! defined $trace_entry->{'msg'};
	$trace_entry->{'ret'} = "" if ! defined $trace_entry->{'ret'};
	$trace_entry->{'elapsed'} = "" if ! defined $trace_entry->{'elapsed'};

	my $ret = sprintf("%s%s%s%s",
		$trace_entry->{'pid'} ne '' ? $trace_entry->{'pid'} . " " : "",
		($config{'show_execnames'} && $trace_entry->{'this_line_execname'} ne "") ? "(" . $trace_entry->{'this_line_execname'} . ") " : "",
		($config{'show_timestamps'} && $trace_entry->{'timestamp'} ne '') ? $trace_entry->{'timestamp'} . " " : "",
		($config{'show_delays'} && $trace_entry->{'delay'} ne '') ? format_delay($trace_entry->{'delay'}) . ' ' : ''
	);

	if ($trace_entry->{'syscall'} ne '') {
		if ($trace_entry->{'ret'} && $config{'adjust_locale'}) {
			$trace_entry->{'ret'} = change_err_locale($trace_entry->{'ret'});
		}

		$ret .= sprintf("%s CALL(%s) = %s",
			$trace_entry->{'syscall'}, $trace_entry->{'args'}, $trace_entry->{'ret'});
	} elsif ($trace_entry->{'msg'} ne '') { # non-call/return
		$ret .= $trace_entry->{'msg'};
	}
	$ret .= sprintf(" <%s>", $trace_entry->{'elapsed'}) if ($config{'show_elapsed'} && $trace_entry->{'elapsed'} ne '');
	return $ret;
}
sub reconstruct_line {
	my ($trace_entry) = @_;

	$trace_entry->{'pid'} = -1 if !defined $trace_entry->{'pid'};
	$trace_entry->{'this_line_execname'} = "" if !defined $trace_entry->{'pid'};
	$trace_entry->{'timestamp'} = "" if ! defined $trace_entry->{'timestamp'};
	$trace_entry->{'delay'} = "" if ! defined $trace_entry->{'delay'};
	$trace_entry->{'syscall'} = "" if ! defined $trace_entry->{'syscall'};
	$trace_entry->{'args'} = "" if ! defined $trace_entry->{'args'};
	$trace_entry->{'msg'} = "" if ! defined $trace_entry->{'msg'};
	$trace_entry->{'ret'} = "" if ! defined $trace_entry->{'ret'};
	$trace_entry->{'elapsed'} = "" if ! defined $trace_entry->{'elapsed'};

	my $ret = sprintf("%s%s%s%s",
		$trace_entry->{'pid'} ne '' ? $trace_entry->{'pid'} . " " : "",
		($config{'show_execnames'} && $trace_entry->{'this_line_execname'} ne "") ? "(" . $trace_entry->{'this_line_execname'} . ") " : "",
		($config{'show_timestamps'} && $trace_entry->{'timestamp'} ne '') ? $trace_entry->{'timestamp'} . " " : "",
		($config{'show_delays'} && $trace_entry->{'delay'} ne '') ? format_delay($trace_entry->{'delay'}) . ' ' : ''
	);

	if ($trace_entry->{'syscall'} ne '') {
		if ($trace_entry->{'ret'} && $config{'adjust_locale'}) {
			$trace_entry->{'ret'} = change_err_locale($trace_entry->{'ret'});
		}

		if ($config{'double_entry'}) {
			$ret .= sprintf("%s RETURN(%s) = %s",
				$trace_entry->{'syscall'}, $trace_entry->{'args'}, $trace_entry->{'ret'});
		} else {
			$ret .= sprintf("%s(%s) = %s",
				$trace_entry->{'syscall'}, $trace_entry->{'args'}, $trace_entry->{'ret'});
		}
	} elsif ($trace_entry->{'msg'} ne '') { # non-call/return
		$ret .= $trace_entry->{'msg'};
	}
	$ret .= sprintf(" <%s>", $trace_entry->{'elapsed'}) if ($config{'show_elapsed'} && $trace_entry->{'elapsed'} ne '');
	return $ret;
}
sub timestamp_to_seconds {
	my $str = shift;

	return 0 if !defined $str;

	if (my ($epoch_str, $subsec) = $str =~ /($patterns{'epoch_time_string'})($patterns{'time_possible_subseconds'})/) {
		return sprintf("%s%s", $epoch_str, $subsec) if defined $subsec;
		return $epoch_str;
	}
	if (my ($h, $m, $s, $subsec) = $str =~ /($patterns{'hours_string'}):($patterns{'minutes_string'}):($patterns{'seconds_string'})($patterns{'time_possible_subseconds'})/) {

		my $ts_sec = ((($h * 60) + $m) * 60) + $s;
		return sprintf("%d%s", $ts_sec, $subsec) if defined $subsec;
		return sprintf("%d", $ts_sec);
	}
	return $str;
}

%patterns = (
	'nothing' => '(?:)?',
	'digits_string' => '[0-9]+',
	'digits_or_negative_digits' => '(?:-)?[0-9]+',
	'hex_string' => '0x[0-9a-f]+',
	'hex_string_or_null' => '(?:0x[0-9a-f]+|NULL)',
	'fd_string' => "[0-9]+",
	'fd_string_or_negative_one' => '(?:[0-9]+|-1)',
	'atfdcwd_string' => "AT_FDCWD",

	'possible_path_string' => "(?:<(.+)>)?",
	'possible_socket_string' => '(?:<(.+)>)?',

	'file_mode_string' => "0[0-7]+",
	'possible_file_mode_string' => "(?:, (0[0-7]+))?",

#	'quoted_string' => "(?:\"(.+)\")",
	'quoted_string' => "(?:\"(.*?)\")",
	'squiggle_braces_arg' => "(?:\{(.+)\})",
	'square_brackets_arg' => '(?:\[([^\]]*)\])',

	'proc_pid_exe' => '(?:"/proc/([0-9]+|self)/exe")',
);
%patterns = (%patterns,

#	'common_pid_string' => '(?<![:\\.0-9])([0-9]+)(?<![\\.A-Za-z:])',
	'standard_pid_string' => "(?:$patterns{'digits_string'})",

#	'alt_pid_string' => "(?:\\[pid )($patterns{'digits_string'})(?:\\])",
#	'alt_pid_string' => "(?:(?:\\[pid )$patterns{'digits_string'}(?:\\]))",
	'alt_pid_string' => "(?:(?:\\[pid )$patterns{'digits_string'}(?:\\]))",
	'extract_alt_pid_string' => "(?:(?:\\[pid )($patterns{'digits_string'})(?:\\]) )",

	'hours_string' => '(?:(?:[01][0-9])|(?:2[0-3]))',
	'minutes_string' => '(?:[0-5][0-9])',
	'seconds_string' => '(?:(?:[0-5][0-9])|60)', # 23:59:60 is posible for leap second
	'time_subseconds' => "(?:\\.[0-9]{3}(?:[0-9]{3}(?:[0-9]{3})?)?)",

	'epoch_time_string' => "(?:[12][0-9]{9}\\b)",
	'relative_time_seconds' => "(?:\\b(?:(?:0|[1-9][0-9]{0,6})))", # smaller integer that can't be epoch time
);
$patterns{'pid_string'} = "(?:(?:$patterns{'standard_pid_string'})|(?:$patterns{'alt_pid_string'}))";
#$patterns{'pid_string'} = "(?|(?:$patterns{'standard_pid_string'})|(?:$patterns{'alt_pid_string'}))";

%patterns = (%patterns,
	'possible_pid_string' => "(?:($patterns{'pid_string'}) )?(?:\\s*)",
	'is_alt_pid' => $patterns{'alt_pid_string'},
#	'extract_alt_pid_string' => "($patterns{'alt_pid_string'})(.+)",
#	'extract_alt_pid_string' => "($patterns{'alt_pid_string'}) (.+)",

	'time_hms_string' => "(?:$patterns{'hours_string'}:$patterns{'minutes_string'}:$patterns{'seconds_string'})",
	'time_possible_subseconds' => "(?:$patterns{'time_subseconds'})?",
	'common_relative_time_string' => "(?:$patterns{'relative_time_seconds'}$patterns{'time_subseconds'})",
	'standard_relative_time_string' => "(?:(?<![:0-9])($patterns{'relative_time_seconds'}$patterns{'time_subseconds'})(?![\\)0-9]))",

	'op_string' => '([a-zA-Z_][^\( ]+)', # going to assume we have at least 2 characters
	'op_args_string' => '(.*?)',
	'possible_other_args' => "(?:, (.+))?",
	'ret_string' => '(?:\s+= (.+?))',
	'possible_elapsed_string' => '(?: <([0-9]+\\.[0-9]+)>)?',
);
%patterns = (%patterns,
	'execname_string' => '(?:\(([^\(\)]+)\))',  # we'll just go ahead and barf if the strace has already had execnames attached, AND the process name has a right paren...

	'timestamp_string' => "(?:(?:$patterns{'time_hms_string'}|$patterns{'epoch_time_string'})$patterns{'time_possible_subseconds'})",
	'alt_relative_time_string' => "(?:\\(\\+\\s*($patterns{'common_relative_time_string'})\\))",
);

$patterns{'my_delay_string'} = "(?:(?:\\+$patterns{'relative_time_seconds'}\.$patterns{'time_possible_subseconds'}))";
$patterns{'my_delay_string2'} = "(?:(?:\\+$patterns{'relative_time_seconds'}$patterns{'time_possible_subseconds'}))";
if (0) {

printf "relative_time_seconds: %s\n", $patterns{'relative_time_seconds'};
printf "time_possible_subseconds: %s\n", $patterns{'time_possible_subseconds'};
printf "my_delay_string:  %s\n", $patterns{'my_delay_string'};
printf "my_delay_string2: %s\n", $patterns{'my_delay_string2'};
exit;
#mds:  (?:(?:\+(?:\b(?:(?:0|[1-9][0-9]{0,6}))).(?:(?:\.[0-9]{3}(?:[0-9]{3}(?:[0-9]{3})?)?))?))
#mds3: (?:(\+[0-9]+(?:(?:\.[0-9]{3}(?:[0-9]{3}(?:[0-9]{3})?)?)?)) )?

#mds:  (?:(?:\+(?:\b(?:(?:0|[1-9][0-9]{0,6}))).(?:(?:\.[0-9]{3}(?:[0-9]{3}(?:[0-9]{3})?)?))?))
#mds3: (?:(\+[0-9]+(?:(?:\.[0-9]{3}(?:[0-9]{3}(?:[0-9]{3})?)?)?)) )?
}

%patterns = (%patterns,
	'possible_timestamp_string' => "(?:($patterns{'timestamp_string'})(?: ))?",
	'possible_relative_time_string' => "(?:(?|\\s*?(?|$patterns{'standard_relative_time_string'}|$patterns{'alt_relative_time_string'})(?: )))?",

#	'possible_delay_string' => "(?:(?:\\+$patterns{'relative_time_seconds'}$patterns{'time_possible_subseconds'}))", # TODO: enable 'alt' delay string format
	'possible_delay_string' => '(?:(\+[0-9]+(?:(?:\.[0-9]{3}(?:[0-9]{3}(?:[0-9]{3})?)?)?)) )?', # TODO: 'alt' delay string format; TODO: non-open-coded

	'fd_with_possible_path' => "($patterns{'fd_string'})$patterns{'possible_path_string'}",
	'fd_or_atfdcwd_string' => "($patterns{'fd_string'}|$patterns{'atfdcwd_string'})",
	'fd_or_negative_one_with_possible_path' => "($patterns{'fd_string_or_negative_one'})$patterns{'possible_path_string'}",

	'possible_pipefd_name' => "(?:<(.+)>)?",
	'possible_sockfd_name' => "(?:<(.+)>)?",

	'newfstatat_flags' => "(0|(?:\||AT_EMPTY_PATH|AT_NO_AUTOMOUNT|AT_SYMLINK_NOFOLLOW)+)",

	# man clone | egrep -o 'CLONE_[^ ,.)]+' | sort -u | paste -s - -d\|
#	'clone_flags' => '(0|(?:\|CLONE_[^\|, ]+
#	'clone_flags' => '(0|(?:\|CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|CLONE_DETACHED|CLONE_FILES|CLONE_FS|CLONE_IO|CLONE_NEWIPC|CLONE_NEWNET|CLONE_NEWNS|CLONE_NEWPID|CLONE_NEWUTS|CLONE_PARENT|CLONE_PARENT_SETTID|CLONE_PID|CLONE_PTRACE|CLONE  _SETTID|CLONE_SETTLS|CLONE_SIGHAND|CLONE_STOPPED|CLONE_SYSVSEM|CLONE_THREAD|CLONE_UNTRACED|CLONE_VFORK|CLONE_VM)+)',

	'signal_name' => '(?:SIG[A-Z0-9_]+)',
	'signal_name_or_val' => '(?:[0-9]+|SIG[A-Z0-9_]+)',
	'siginfo_t' => "(?:\{si_signo=(?:SIG[A-Z0-9_]+), si_code.+\})",

	'clone_flags' => '(0|(?:\\||CLONE_[A-Z0-9_]+|SIG[A-Z0-9]+)+)',

	'clockid' => '(?:CLOCK_[A-Z_]+)',
	'timerfd_flags' => '(?:0|(?:\\||(?:TFD_[A-Z]+))+)',
	'epoll_create1_flags' => '(0|(?:\\||EPOLL_CLOEXEC))',
	'open_flags' => "(0|(?:\\||O_[A-Z0-9_]+)+)",
	'dup3_flags' => "(0|O_CLOEXEC)",
	'renameat2_flags' => '([0-9]+|(?:\\||RENAME_[A-Z0-9_]+)+)',

	'fcntl_cmd' => '(F_[^, ]+)',
#	'fcntl_args' => '(.+)?',
	'fcntl_args' => "$patterns{'possible_other_args'}",

#	'generic_arg' => '(?:, (.+?))',
	'generic_arg' => '(.+?)',

	'execve_path_string' => '(?:"([^"]+)")',
	'execve_argv_string' => '(?:\[([^\]]+)\])',
#	'execve_envp_string' => '(?:\[(.+)\])',
#	'execve_envp_string' => '(?:\[(.+)\](?:.*?))',
	'execve_envp_string' => '(?:(.+?))',
#"/home/ceh1/apps/proteus/beta/proteus_003_414_000/misc/../bin/LINUX_P4_V6/opt-shared-gcc447/fosv_uniserverd", ["/home/ceh1/apps/proteus/beta/pro"..., "-cachelimit", "1500000", "-logdir", "/home/ceh1/apps/proteus/cbb3/log"..., "-requestingPID", "fosv_ObjMultiServerSymph:fosrv:i"..., "-nscdport", "43911"], 0x7ffdbe5880d0 /* 84 vars */
#"/path/../more/path/exe", ["/path/..., "-cachelimit", "1500000", "-logdir", "arg"..., "-requestingPID", "arg:fosrv:i"..., "-nscdport", "32953"], 0x7ffe60315260 /* 84 vars */

#	'socket_domain' => '(?:AF_[A-Z0-9]+)',
	'socket_domain' => '(?:[AP]F_[A-Z0-9]+)',
#	'socket_type' => '(?:SOCK_[A-Z]+)',
#	'socket_type' => '(0|(?:\\||SOCK_[A-Z]]+)+)',
#	'socket_type' => '(?:0|SOCK_
	'socket_type' => '(?:0|SOCK_[A-Z]+(?:|(\\|SOCK[A-Z]+)+))',

#((?:AF_[A-Z0-9]+)), ((?:0|SOCK_[A-Z]+(?:|(\|SOCK[A-Z]+)+))), ((?:.+?))

	'socket_proto' => '(?:.+?)',
	'fd_with_possible_socket_string' => "($patterns{'fd_string'})$patterns{'possible_socket_string'}",

	'possible_argument' => "(?:, (.+))?",
	'possible_int_argument' => "(?:, (0[0-7]+))?",
	'everything_else' => "(.+)?",

	'return_error_string' => "-1 (E[^ ]+)\((.+)\)",
);

$patterns{'fd_or_atfdcwd_with_possible_path'} = "$patterns{'fd_or_atfdcwd_string'}$patterns{'possible_path_string'}";

$patterns{'pipefd_with_possible_name'} = "($patterns{'fd_string'})$patterns{'possible_pipefd_name'}";
$patterns{'sockfd_with_possible_name'} = "($patterns{'fd_string'})$patterns{'possible_sockfd_name'}";
$patterns{'possible_renameat2_flags'} = "(?:, $patterns{'renameat2_flags'})?",

%patterns = (%patterns,
	'syscall' => "$patterns{'possible_pid_string'}$patterns{'possible_timestamp_string'}$patterns{'possible_relative_time_string'}$patterns{'op_string'}\($patterns{'op_args_string'}\)$patterns{'ret_string'}$patterns{'possible_elapsed_string'}",
);

%regexes = (
	'unfinished' => qr/^$patterns{'possible_pid_string'}$patterns{'possible_timestamp_string'}$patterns{'possible_relative_time_string'}$patterns{'op_string'}\($patterns{'op_args_string'} <unfinished \.\.\.>$/,
	'resumed' => qr/^$patterns{'possible_pid_string'}$patterns{'possible_timestamp_string'}$patterns{'possible_relative_time_string'}<... $patterns{'op_string'} resumed>$patterns{'everything_else'}$/,
	'resuming_unfinished' => qr/^$patterns{'possible_pid_string'}$patterns{'possible_timestamp_string'}$patterns{'possible_relative_time_string'}restart_syscall\(<\.\.\. resuming interrupted ($patterns{'op_string'}) \.\.\.> <unfinished \.\.\.>$/,
	'killed' => qr/^\+\+\+ killed by ($patterns{'signal_name'}) \+\+\+$/,
);

# various prefixes for '-f' '-t*' and '-r' arguments

# 'strace -t' -- timestamp with seconds
# 14:20:14 execve("/usr/bin/find", ["find", "-exec", "ls", "-lind", "{}", ";"], 0x7fff8a3e6290 /* 91 vars */) = 0

# 'strace -tt' or 'strace -f -tt' before seeing other pids -- timestamp with microseconds
# 14:20:26.534495 execve("/usr/bin/find", ["find", "-exec", "ls", "-lind", "{}", ";"], 0x7ffc88c8f5a0 /* 91 vars */) = 0
# 14:20:26.538707 brk(NULL)               = 0x563bb864e000
# 14:20:26.538840 arch_prctl(0x3001 /* ARCH_??? */, 0x7ffeefdb90e0) = -1 EINVAL (Invalid argument)

# 'strace -f -tt' -- alternate pid, timestamp with microseconds
# [pid 4120863] 14:23:52.016152 read(3, "", 4096) = 0
# [pid 4120863] 14:23:52.016224 close(3)  = 0
# [pid 4120863] 14:23:52.016336 openat(AT_FDCWD, "/usr/share/locale/en_US.UTF-8/LC_TIME/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)

# 'strace -ttt' or 'strace -f -ttt' before seeing other pids -- epoch_time timestamp with microseconds
# 1628968554.808565 execve("/usr/bin/find", ["find", "-exec", "ls", "-lind", "{}", ";"], 0x7ffdd8c6dc70 /* 91 vars */) = 0
# 1628968554.812065 brk(NULL)             = 0x55fd21615000
# 1628968554.812297 arch_prctl(0x3001 /* ARCH_??? */, 0x7ffc558797b0) = -1 EINVAL (Invalid argument)
# *** compare with '-r' below--the time is very large in comparison
#   i.e.     0.000106 arch_prctl(0x3001 /* ARCH_??? */, 0x7ffcf7e6b620) = -1 EINVAL (Invalid argument)


# 'strace -f -ttt' -- alternate pid, epoch_time timestamp with microseconds
# [pid 4119921] 1628968560.410797 read(3, "", 4096) = 0
# [pid 4119921] 1628968560.410840 close(3) = 0
# [pid 4119921] 1628968560.410898 openat(AT_FDCWD, "/usr/share/locale/en_US.UTF-8/LC_TIME/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)
# compare with '-f -r' below--the time is very large in comparison
#   i.e. [pid 4116430]      0.000143 fchdir(3)   = 0


# with relative time
# 'strace -r' or 'strace -f -r' before any other pids are seen -- relative time
#     0.000000 execve("/usr/bin/find", ["find", "-exec", "ls", "-lind", "{}", ";"], 0x7ffd94252e00 /* 91 vars */) = 0
#     0.002258 brk(NULL)                 = 0x559f16f73000
#     0.000106 arch_prctl(0x3001 /* ARCH_??? */, 0x7ffcf7e6b620) = -1 EINVAL (Invalid argument)
# *** compare with '-ttt' above--the time is very small in comparison

# 'strace -t -r' or 'strace -f -t -r' before other pids seen -- timestamp with seconds, relative time
# 14:26:05 (+     0.000000) execve("/usr/bin/find", ["find", "-exec", "ls", "-lind", "{}", ";"], 0x7ffe8646c540 /* 91 vars */) = 0
# 14:26:05 (+     0.002050) brk(NULL)     = 0x56372a308000
# 14:26:05 (+     0.000189) arch_prctl(0x3001 /* ARCH_??? */, 0x7ffc3e602840) = -1 EINVAL (Invalid argument)

# 'strace -f -t -r' -- alternate pid, timestamp with seconds, relative time
# [pid 4121485] 14:27:33 (+     0.000100) read(3, "", 4096) = 0
# [pid 4121485] 14:27:33 (+     0.000066) close(3) = 0
# [pid 4121485] 14:27:33 (+     0.000093) openat(AT_FDCWD, "/usr/share/locale/en_US.UTF-8/LC_TIME/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)

# 'strace -tt -r' or 'strace -f -tt -r' before seeing other pids -- timestamp with microseconds, relative time
# 14:28:51.537819 (+     0.000000) execve("/usr/bin/find", ["find", "-exec", "ls", "-lind", "{}", ";"], 0x7ffcaa714378 /* 91 vars */) = 0
# 14:28:51.541680 (+     0.003364) brk(NULL) = 0x55801d13d000
# 14:28:51.541758 (+     0.000076) arch_prctl(0x3001 /* ARCH_??? */, 0x7ffdffb929d0) = -1 EINVAL (Invalid argument)

# 'strace -f -tt -r' -- alternate pid, timestamp with microseconds, relative time
# [pid 4121876] 14:30:03.015841 (+     0.000141) read(3, "", 4096) = 0
# [pid 4121876] 14:30:03.015943 (+     0.000100) close(3) = 0
# [pid 4121876] 14:30:03.016096 (+     0.000153) openat(AT_FDCWD, "/usr/share/locale/en_US.UTF-8/LC_TIME/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)

# 'strace -ttt -r' or 'strace -f -ttt -r' before seeing other pids -- epoch timestamp with microseconds, relative time
# 1628969468.717642 (+     0.000000) execve("/usr/bin/find", ["find", "-exec", "ls", "-lind", "{}", ";"], 0x7ffedb8d4bc8 /* 91 vars */) = 0
# 1628969468.720367 (+     0.002346) brk(NULL) = 0x55bdf5f49000
# 1628969468.720494 (+     0.000124) arch_prctl(0x3001 /* ARCH_??? */, 0x7ffcd100fb50) = -1 EINVAL (Invalid argument)

# 'strace -f -ttt -r' -- alternate pid, epoch timestamp with microseconds, relative time
# [pid 4122385] 1628969555.594034 (+     0.000103) read(3, "", 4096) = 0
# [pid 4122385] 1628969555.594102 (+     0.000068) close(3) = 0
# [pid 4122385] 1628969555.594213 (+     0.000110) openat(AT_FDCWD, "/usr/share/locale/en_US.UTF-8/LC_TIME/coreutils.mo", O_RDONLY) = -1 ENOENT (No such file or directory)

# 'strace -f -r' -- alternate pid, relative_time
# [pid 4116429]      0.000370 wait4(4116430,  <unfinished ...>
# [pid 4116430]      0.000043 set_robust_list(0x7f781128d720, 24) = 0
# [pid 4116430]      0.000143 fchdir(3)   = 0
#   compare with '-f -ttt' above -- the time is very small in comparison
#   i.e.: 1628968554.812065 brk(NULL)             = 0x55fd21615000


%regexes = (%regexes,

#	'syscall' => qr/^$patterns{'possible_pid_string'}$patterns{'possible_timestamp_string'}$patterns{'possible_relative_time_string'}$patterns{'op_string'}\($patterns{'op_args_string'}\)$patterns{'ret_string'}$patterns{'possible_elapsed_string'}$/,
	'syscall' => qr/^$patterns{'op_string'}\($patterns{'op_args_string'}\)$patterns{'ret_string'}$/,

	'new_syscall' => qr/^$patterns{'op_string'}\($patterns{'op_args_string'}\)$patterns{'ret_string'}$/,

#	'syscall' => qr/^$patterns{'syscall'}$/,
	'process_exited' => qr/^$patterns{'possible_pid_string'}$patterns{'possible_timestamp_string'}$patterns{'possible_relative_time_string'}(\+\+\+ exited with ($patterns{'digits_string'}) \+\+\+)/,
	'process_signal' => qr/^$patterns{'possible_pid_string'}$patterns{'possible_timestamp_string'}$patterns{'possible_relative_time_string'}--- ($patterns{'signal_name'}) ($patterns{'siginfo_t'}) ---/,
	'strace_partial_line' => qr/^$patterns{'possible_pid_string'}$patterns{'possible_timestamp_string'}$patterns{'possible_relative_time_string'}([^ ]+)\((.+)/,

	'line_with_execname' => qr/^$patterns{'possible_pid_string'}(?:$patterns{'execname_string'}\s+)$patterns{'possible_timestamp_string'}([^ \(]+.+)$/,

	'extract_alt_pid' => qr/^$patterns{'extract_alt_pid_string'}$/,
	'is_alt_pid' => qr/^$patterns{'is_alt_pid'}/,

	'extract_elapsed' => qr/^(.+?)$patterns{'possible_elapsed_string'}$/,
	'extract_delay' => qr/^$patterns{'possible_pid_string'}$patterns{'possible_timestamp_string'}$patterns{'possible_relative_time_string'}(.\+)$/,
	'extract_delay2' => qr/^$patterns{'possible_pid_string'}$patterns{'possible_timestamp_string'}$patterns{'my_delay_string'}(.\+)$/,

	'extract_metadata' =>  qr/$patterns{'possible_pid_string'}(?:\s*)$patterns{'possible_timestamp_string'}$patterns{'possible_delay_string'}(.+?)$patterns{'possible_elapsed_string'}$/,

	'extract_err_name' => qr/-1 (E[^ ]+) \(([^\)]+)\)/,

	'getcwd' => qr/^$patterns{'quoted_string'}, $patterns{'digits_string'}/, # don't capture digits unless we come up with a reason later

#	'fstat' => qr/^$patterns{'fd_with_possible_path'}, $patterns{'squiggle_braces_arg'}$/,
	'newfstatat' => qr/^$patterns{'fd_or_atfdcwd_with_possible_path'}, $patterns{'quoted_string'}, $patterns{'squiggle_braces_arg'}, $patterns{'newfstatat_flags'}$/,

	'creat' => qr/^$patterns{'quoted_string'}, $patterns{'file_mode_string'}$/,

	'open' => qr/^$patterns{'quoted_string'}, $patterns{'open_flags'}$patterns{'possible_file_mode_string'}$/,
	'openat' => qr/^$patterns{'fd_or_atfdcwd_with_possible_path'}, $patterns{'quoted_string'}, $patterns{'open_flags'}$patterns{'possible_file_mode_string'}$/,

	'close' => qr/^$patterns{'fd_with_possible_path'}$/,

	'chdir' => qr/^$patterns{'quoted_string'}/,
	'fchdir' => qr/^$patterns{'fd_with_possible_path'}$/,

#	'fcntl' => qr/^$patterns{'fd_with_possible_path'}, $patterns{'fcntl_cmd'}$patterns{'fcntl_args'}/,
	'fcntl' => qr/^$patterns{'fd_with_possible_path'}, $patterns{'fcntl_cmd'}$patterns{'possible_other_args'}/,

#	'mmap' => qr/^$patterns{'generic_arg'}, $patterns{'generic_arg'}, $patterns{'generic_arg'}, $patterns{'generic_arg'}, $patterns{'fd_with_possible_path'}, $patterns{'generic_arg'}/,
	'mmap' => qr/^$patterns{'generic_arg'}, $patterns{'generic_arg'}, $patterns{'generic_arg'}, $patterns{'generic_arg'}, $patterns{'fd_or_negative_one_with_possible_path'}, $patterns{'generic_arg'}/,

	'dup' => qr/^$patterns{'fd_with_possible_path'}/,
	'dup2' => qr/^$patterns{'fd_with_possible_path'}, ($patterns{'fd_string'})$/,
	'dup3' => qr/^$patterns{'fd_with_possible_path'}, ($patterns{'fd_string'}), ($patterns{'dup3_flags'})$/,

	'pipe' => qr/^\[$patterns{'pipefd_with_possible_name'}, $patterns{'pipefd_with_possible_name'}\]$/,
	'socketpair' => qr/^($patterns{'socket_domain'}), ($patterns{'socket_type'}), ($patterns{'socket_proto'}), (\[$patterns{'sockfd_with_possible_name'}, $patterns{'sockfd_with_possible_name'}\])$/,
#	'socket' => qr/^($patterns{'socket_domain'}), ($patterns{'socket_type'}), ($patterns{'socket_proto'})$/,
	'socket' => qr/^($patterns{'socket_domain'}), (.+?), (.+?)$/,
	'socket_ret' => qr/^$patterns{'fd_with_possible_socket_string'}/,
#	'socket' => qr/^($patterns{'socket_domain'}), ($patterns{'generic_arg'}), ($patterns{'generic_arg'})$/,
#	'socket' => qr/^($patterns{'generic_arg'}), ($patterns{'generic_arg'}), ($patterns{'generic_arg'})$/,

	'timerfd_create' => qr/^($patterns{'clockid'}), ($patterns{'timerfd_flags'})/,

	'epoll_create1' => qr/^$patterns{'epoll_create1_flags'}/,
	'epoll_wait' => qr/^$patterns{'fd_with_possible_path'}, $patterns{'square_brackets_arg'}, ($patterns{'digits_string'}), ($patterns{'digits_string'})$/,

	'proc_pid_cmdline' => qr/^(?:\/proc\/([0-9]+|self)\/cmdline)/,
	'proc_pid_cmdline_read' => qr/^(.+?)\\0(?:.*)/,

	'readlink' => qr/$patterns{'proc_pid_exe'}, $patterns{'quoted_string'}, $patterns{'digits_string'}$/,

	'chroot' => qr/^"(.+)"$/,

#	'clone' => qr/^child_stack=$patterns{'hex_string_or_null'}, flags=($patterns{'clone_flags'}), parent_tidptr=$patterns{'hex_string'}, tls=$patterns{'hex_string'}, child_tidptr=$patterns{'hex_string'}$/,
	'clone' => qr/^child_stack=$patterns{'hex_string_or_null'}, flags=($patterns{'clone_flags'})(, .+)?$/,
# clone(child_stack=0x7fc9df076fb0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0x7fc9df0779d0, tls=0x7fc9df077700, child_tidptr=0x7fc9df0779d0) = 9057
# clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f21efcbba10) = 1447033

	'clone3' => qr/^\{([^\}]+)\} => \{([^\}]+)\}, ([0-9]+)$/,
# "([^}]+} => {parent_tid=\[[0-9]+\]}, ([0-9]+)"
#       long syscall(SYS_clone3, struct clone_args *cl_args, size_t size);
#clone3({flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, child_tid=0x7f075c670910, parent_tid=0x7f075c670910, exit_signal=0, stack=0x7f075be70000, stack_size=0x7ffec0, tls=0x7f075c670640} => {parent_tid=[4137880]}, 88) = 4137880
#4137042 14:47:13.080710 clone3({flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, child_tid=0x7f075ce71910, parent_tid=0x7f075ce71910, exit_signal=0, stack=0x7f075c671000, stack_size=0x7ffec0, tls=0x7f075ce71640} => {parent_tid=[4137881]}, 88) = 4137881 <0.000080>

	'kill' => qr/^($patterns{'digits_or_negative_digits'})(?: $patterns{'execname_string'})?, ($patterns{'signal_name_or_val'})$/,

#	'generic_function_fd' => qr/^$patterns{'fd_or_negative_one_with_possible_path'}, $patterns{'everything_else'}$/,
	'generic_function_fd' => qr/^$patterns{'fd_or_negative_one_with_possible_path'}$patterns{'possible_other_args'}$/,
	'generic_function_dfd_path' => qr/^$patterns{'fd_or_atfdcwd_with_possible_path'}, ($patterns{'quoted_string'}|NULL), $patterns{'everything_else'}$/,

	'renameat' => qr/^$patterns{'fd_or_atfdcwd_with_possible_path'}, $patterns{'quoted_string'}, $patterns{'fd_or_atfdcwd_with_possible_path'}, $patterns{'quoted_string'}$patterns{'possible_renameat2_flags'}$/,
	'read' => qr/^$patterns{'fd_or_negative_one_with_possible_path'}, "(.+)", ([0-9]+)$/,

	'execve' => qr/^$patterns{'execve_path_string'}, $patterns{'execve_argv_string'}, $patterns{'execve_envp_string'}$/,
	'execve_pwd_path' => qr/^(.*?)(?:"PWD=([^"]+)")(.*?)$/,

	'return_fd_path' => qr/^$patterns{'fd_with_possible_path'}$/,
	'return_error' => qr/$patterns{'return_error_string'}$/,

);
#1119840 16:59:55.153682 openat(AT_FDCWD, "/usr/share/locale/locale.alias", O_RDONLY|O_CLOEXEC) = 3</usr/share/locale/locale.alias> <0.000037>
#1120026 17:00:32.779494 openat(5</home/sos/2948400>, "sosreport-testbic1wn2l-2021-05-26-crzdojg", O_RDONLY|O_NOCTTY|O_NONBLOCK|O_NOFOLLOW|O_CLOEXEC|O_DIRECTORY) = 6</home/sos/2948400/sosreport-testbic1wn2l-2021-05-26-crzdojg> <0.000058>
# int openat(int dirfd, const char *pathname, int flags, mode_t mode);

my $extract_pid_str = qr/^($patterns{'pid_string'})$/;
my $extract_timestamp_str = qr/^($patterns{'timestamp_string'})$/;
my $extract_delay_str = qr/^(\+[0-9]+(?:(?:\.[0-9]{3}(?:[0-9]{3}(?:[0-9]{3})?)?)?))$/;
#my $extract_elapsed = qr/(.+) <([0-9.]+)>$/;S
my $extract_elapsed_str = qr/^<([0-9]+\.[0-9]+)>$/;
sub extract_metadata {
	my ($trace_entry) = @_;
	my $elapsed;
	my $remain = $trace_entry->{'line'};
	my $rest;

	my @vals = (split / /, $remain);

	if ($config{'debug'} >= 2) {
		printf "when extracting metadata: \n";
		foreach my $z (@vals) {
			printf "    *%s*\n", $z;
		}
		printf "\n";
	}

	if ($vals[0] =~ $extract_pid_str) {
		$trace_entry->{'pid'} = $1;
		shift @vals;
	} else {
		$trace_entry->{'pid'} = -1;
	}

	shift @vals while ($vals[0] eq ""); # sometimes pid is padded with spaces

	if ($vals[0] =~ $extract_timestamp_str) {
		$trace_entry->{'timestamp'} = $1;
		$tracking_data{'trace_stats'}{'start_time'} = $trace_entry->{'timestamp'} if (! defined $tracking_data{'trace_stats'}{'start_time'});
		$tracking_data{'trace_stats'}{'end_time'} = $trace_entry->{'timestamp'};
		shift @vals;
	} else {
		$trace_entry->{'timestamp'} = '';
	}
	if ($vals[0] =~ $extract_delay_str) {
		$trace_entry->{'delay'} = $1;
		shift @vals;
	} else {
		$trace_entry->{'delay'} = '';
	}
	if ($vals[-1] =~ $extract_elapsed_str) {
		$trace_entry->{'elapsed'} = $1;
		pop @vals;
	} else {
		$trace_entry->{'elapsed'} = 0;
	}

	$trace_entry->{'line'} = join(" ", @vals);
}

# functions with the first argument being an fd
@generic_fd_functions = (
	"futimens", "flock", 'ftruncate',
	"fchmod", "fchown", "flock", "fstat", "fstat64", "fstatfs",

	'read', 'readv', 'pread', 'preadv', 'preadv2', 'pread64',
	'write', 'writev', 'pwrite', 'pwritev', 'pwritev2', 'pwrite64',

	'inotify_add_watch', 'inotify_rm_watch',

	"lseek", '_llseek',
	"fadvise64", 'fallocate',
	"fsync", "fdatasync",
	"ioctl",
	'epoll_wait', # TODO: anything to parse?
	'epoll_ctl', # TODO: 3rd arg 'fd'
	'epoll_pwait', # TODO: other fd args
	'epoll_pwait2', # TODO: other fd args

	'splice', # TODO: 1st arg 'fd_in', 3rd arg 'fd_out'
	'getpeername',
	'timerfd_settime',

	'connect', "setsockopt", 'bind', 'listen', 'shutdown', 'accept', 'accept4',
	'send', 'sendto', 'sendmsg', 'sendmmsg',

);

@generic_dfd_pathname_functions = ( "faccessat", "fchownat", "unlinkat", "fchmodat",
	"utimensat", "futimensat", "mkdirat", "fstatat", "fstatat64", 'statx',
	"newfstatat", "readlinkat",
	"name_to_handle_at",
);
#@generic_dfd_pathname_functions = (@generic_dfd_pathname_functions, "name_to_handle_at");

@to_be_implemented = (
	'mmap', 'mmap2',
	'pipe2',
	'select', 'pselect', 'pselect6', 'poll', 'ppoll',

	'io_cancel', # TODO: parse args for the fds
	'io_destroy', # TODO: parse args for the fd
	'io_getevents', # TODO: parse args for fds
	'io_setup', # TODO: parse args for the fds
	'io_submit', # TODO: parse args for fds

	'io_uring_enter',
	'io_uring_register',
	'io_uring_setup',
);
# TODO: handle-based functions

# creat open close fchdir dup dup2 dup3 fcntl unlinkat symlinkat
# fsync ioctl select
#       int symlinkat(const char *target, int newdirfd, const char *linkpath);
@no_parsing_functions = (
	@to_be_implemented,
	'access', 'alarm', 'arch_prctl',

	'brk',

	'capget', 'capset',
	"chmod", 'chown', 'clock_gettime', 'clock_getres',

	'exit_group',

	'futex',

	# TODO:

	"get_mempolicy",
	"getgroups", "getpgrp", 'getpid', "getppid", "getpriority",
	"getrandom", 'getrlimit', "getrusage", "getsid",
	"getsockname", "getsockopt", 'getxattr', 'lgetxattr',
	'getuid', 'geteuid', 'getreuid', 'getresuid',
	'getgid', 'getegid', 'getresgid',
	'gettid', # TODO:
	'getpgid',

	'ioprio_get',
	'ioprio_set',

	"keyctl", 'kill',

	'lchown', 'listxattr', 'lstat',

	'madvise', 'mbind', 'mkdir', 'mknod',
	'mlock', 'mprotect', 'mremap', 'msync', 'munmap',
	'mount',

	"nanosleep",

	'pipe2', 'ppoll', 'prlimit', 'prlimit64',

	'prctl',

	"recvfrom", "recvmsg", "rename", 'restart_syscall', 'rmdir',
	'rt_sigaction', "rt_sigpending", 'rt_sigprocmask', 'rt_sigqueueinfo',
	'rt_sigreturn', "rt_sigtimedwait",

	'rseq',

	"sched_setscheduler", "sched_get_priority_min", "sched_get_priority_max",
	"sched_setpriority_min", "sched_setpriority_max",
	"semctl", "semget", "semop",
	"setgid", "setgroups", "setpriority",
	'setitimer',
	'setrlimit',
	"setregid", "setresgid", 'setsid',
	'set_thread_area',
	'setpgid',
	'stat', 'stat64',

	'setuid', 'seteuid', 'setreuid', 'setresuid',
	'sched_yield', 'sched_getaffinity', 'sched_setaffinity',
	'set_robust_list', 'set_tid_address', 'statfs',

	'setxattr',
	"shmat", "shmctl", "shmdt", "shmget",
	"sigaltstack", "sysinfo",
	"symlink", # TODO: relative paths "symlinkat", # TODO: 2nd arg is a dfd

	"tgkill", 'timer_delete', 'times',

	'umount', 'umount2',
	'uname', 'unlink', "umask",
	'wait4', 'waitpid',
);
@no_parsing_functions = (@no_parsing_functions, "open_by_handle_at");

# TODO: clone execve(cloexec) exit_group select pselect6 pipe

# socket connect poll
#

#$ kill -l | egrep -o '([0-9]+)\) ([-A-Z0-9+]+)' | tr -d \) | awk '{printf "\"%d\" => \"%s\",\n", $1, $2}'
my %sig_names = (
		"1" => "SIGHUP", "2" => "SIGINT", "3" => "SIGQUIT", "4" => "SIGILL", "5" => "SIGTRAP",
		"6" => "SIGABRT", "7" => "SIGBUS", "8" => "SIGFPE", "9" => "SIGKILL", "10" => "SIGUSR1",
		"11" => "SIGSEGV", "12" => "SIGUSR2", "13" => "SIGPIPE", "14" => "SIGALRM", "15" => "SIGTERM",
		"16" => "SIGSTKFLT", "17" => "SIGCHLD", "18" => "SIGCONT", "19" => "SIGSTOP", "20" => "SIGTSTP",
		"21" => "SIGTTIN", "22" => "SIGTTOU", "23" => "SIGURG", "24" => "SIGXCPU", "25" => "SIGXFSZ",
		"26" => "SIGVTALRM", "27" => "SIGPROF", "28" => "SIGWINCH", "29" => "SIGIO", "30" => "SIGPWR",
		"31" => "SIGSYS", "34" => "SIGRTMIN", "35" => "SIGRTMIN+1",
		"36" => "SIGRTMIN+2", "37" => "SIGRTMIN+3", "38" => "SIGRTMIN+4", "39" => "SIGRTMIN+5", "40" => "SIGRTMIN+6",
		"41" => "SIGRTMIN+7", "42" => "SIGRTMIN+8", "43" => "SIGRTMIN+9", "44" => "SIGRTMIN+10", "45" => "SIGRTMIN+11",
		"46" => "SIGRTMIN+12", "47" => "SIGRTMIN+13", "48" => "SIGRTMIN+14", "49" => "SIGRTMIN+15", "50" => "SIGRTMAX-14",
		"51" => "SIGRTMAX-13", "52" => "SIGRTMAX-12", "53" => "SIGRTMAX-11", "54" => "SIGRTMAX-10", "55" => "SIGRTMAX-9",
		"56" => "SIGRTMAX-8", "57" => "SIGRTMAX-7", "58" => "SIGRTMAX-6", "59" => "SIGRTMAX-5", "60" => "SIGRTMAX-4",
		"61" => "SIGRTMAX-3", "62" => "SIGRTMAX-2", "63" => "SIGRTMAX-1", "64" => "SIGRTMAX",
);

#sub syscall_
sub syscall_getcwd {
	my ($trace_entry) = @_;
	printf("matched the getcwd pattern\n") if ($config{'debug'} >= 1);
	if (my ($path) = $trace_entry->{'args'} =~ $regexes{'getcwd'}) {
		set_cwd($trace_entry->{'pid'}, $path) if (!ret_is_error($trace_entry->{'ret'}));
	} else {
		printf("getcwd op, but didn't match the re\n");
	}
}
sub syscall_chdir {
	my ($trace_entry) = @_;

	if (my ($path) = $trace_entry->{'args'} =~ $regexes{'chdir'}) {
		set_cwd($trace_entry->{'pid'}, $path) if (!ret_is_error($trace_entry->{'ret'}));
	} else { printf("chdir, but didn't match the re\n"); }
}
sub syscall_fchdir {
	my ($trace_entry) = @_;
	if (my ($fd, $fd_path) = $trace_entry->{'args'} =~ $regexes{'fchdir'}) {
		$fd_path = get_fd_path($trace_entry->{'pid'}, $fd) if (!defined($fd_path));
		set_cwd($trace_entry->{'pid'}, $fd_path) if ($fd_path ne "" && !ret_is_error($trace_entry->{'ret'}));
	} else {printf("fchdir but didn't match the re\n"); }
}
sub syscall_creat {
	my ($trace_entry) = @_;

	# essentially calls open with O_CREAT|O_WRONLY|O_TRUNC
	if (my ($pathname, $open_mode) = $trace_entry->{'args'} =~ $regexes{'creat'}) {
		printf("matched 'creat' regex\n") if ($config{'debug'} >= 1);
		if ($config{'debug'} >= 2) {
			printf("%16s - %s\n", "pathname", get_match_val($pathname));
			printf("%16s - %s\n", "open mode", get_match_val($open_mode));
		}
		if (!ret_is_error($trace_entry->{'ret'}) and my ($fd, $fd_path) = $trace_entry->{'ret'} =~ $regexes{'return_fd_path'}) {
			if (defined($fd_path)) {
				store_fd_name($trace_entry->{'pid'}, $fd, $fd_path);
			} else {
				store_fd_name($trace_entry->{'pid'}, $fd, $pathname);
				$trace_entry->{'ret'} = sprintf("%d<%s>", $fd, $pathname);
			}
		}
	} else {
		printf("creat, but didn't match the re\n");
	}
}
sub syscall_open {
	my ($trace_entry) = @_;
	if (my ($pathname, $open_flags, $open_mode) = $trace_entry->{'args'} =~ $regexes{'open'}) {
			printf("matched 'open' regex\n") if ($config{'debug'} >= 1);
		if ($config{'debug'} >= 2) {
			printf("%16s - %s\n", "pathname", get_match_val($pathname));
			printf("%16s - %s\n", "open flags", get_match_val($open_flags));
			printf("%16s - %s\n", "open mode", get_match_val($open_mode));
		}
		if (!ret_is_error($trace_entry->{'ret'}) and my ($fd, $fd_path) = $trace_entry->{'ret'} =~ $regexes{'return_fd_path'}) {
			if ($config{'debug'} >= 2) {
				printf("  return fd: %d\n", get_match_val($fd));
				printf("  return fd path: %s\n", get_match_val($fd_path));
			}
			if (defined($fd_path) && $fd_path ne "") {
				store_fd_name($trace_entry->{'pid'}, $fd, $fd_path);
				set_cwd($trace_entry->{'pid'}, $fd_path) if ($pathname eq "."); # determined cwd from return string
				printf("derived CWD from open(\".\"...): '%s'\n", $fd_path) if ($config{'debug'} >= 1);
			} else {
				# see if we can determine the path from $cwd and $pathname
				$fd_path = get_atpath($trace_entry->{'pid'}, "AT_FDCWD", $pathname);
				store_fd_name($trace_entry->{'pid'}, $fd, $fd_path);
				$trace_entry->{'ret'} = sprintf("%d<%s>", $fd, $fd_path);
			}
		} else { # otherwise, error or couldn't parse return string
			printf "  open() error\n" if (ret_is_error($trace_entry->{'ret'}) && $config{'debug'} >= 1);
			printf "  open() NOT error\n" if (!ret_is_error($trace_entry->{'ret'}) && $config{'debug'} >= 1);

			if (!ret_is_error($trace_entry->{'ret'})) {

if (my ($foo1, $foo2) = $trace_entry->{'ret'} =~ $regexes{'return_fd_path'}) {
	printf "matched the return_fd_path... foo1: %s\n", $foo1;
} else {
	printf "did not match the return_fd_path with '%s'\n", $trace_entry->{'ret'};
}

			}

		}
	} else {
		printf("open, but didn't match the re for args '%s'\n", $trace_entry->{'args'});
	}
}
sub syscall_openat {
	my ($trace_entry) = @_;

	if (my ($dfd, $dfd_path, $pathname, $open_flags, $open_mode) = $trace_entry->{'args'} =~ $regexes{'openat'}) {
		my $rebuild_args = false;

		printf("matched 'openat' regex\n") if ($config{'debug'} >= 1);
		if ($config{'debug'} >= 2) {
			printf("%16s - %s\n", "dfd", get_match_val($dfd));
			printf("%16s - %s\n", "dfd_path", get_match_val($dfd_path));
			printf("%16s - %s\n", "pathname", get_match_val($pathname));
			printf("%16s - %s\n", "open flags", get_match_val($open_flags));
			printf("%16s - %s\n", "open mode", get_match_val($open_mode));
		}
		if (!defined($dfd_path)) {
			$dfd_path = get_fd_path($trace_entry->{'pid'}, $dfd);
			$rebuild_args = true if ($dfd_path ne "");
		}
		if (!ret_is_error($trace_entry->{'ret'}) and my ($fd, $fd_path) = $trace_entry->{'ret'} =~ $regexes{'return_fd_path'}) {
			if ($config{'debug'} >= 2) {
				printf("  return fd: %d\n", get_match_val($fd));
				printf("  return fd path: %s\n", get_match_val($fd_path));
			}
#					$fd_path = get_atpath($pid, $dfd, $pathname) if (!defined($fd_path));
			if (!defined($fd_path)) {
				$fd_path = get_atpath($trace_entry->{'pid'}, $dfd, $pathname);
				$trace_entry->{'ret'} = sprintf("%d<%s>", $fd, $fd_path);
			}
			store_fd_name($trace_entry->{'pid'}, $fd, $fd_path);
			if ($dfd eq "AT_FDCWD" and $pathname eq "." and $fd_path ne "") {
				printf("derived CWD from openat(AT_FDCWD, \".\"...): '%s'\n", $fd_path) if ($config{'debug'} >= 1);
				set_cwd($trace_entry->{'pid'}, $fd_path);
			}
		}
		$trace_entry->{'args'} = sprintf("%s%s, \"%s\", %s%s",
			$dfd,
			(($dfd_path ne "") ? "<" . $dfd_path . ">" : ""),
			$pathname, $open_flags,
			(defined($open_mode) ? ", " . $open_mode : "")) if ($rebuild_args);
	} else {
		printf("openat, but didn't match the re\n");
	}
}
sub syscall_openat2 {
	my ($trace_entry) = @_;
	if (my ($dfd, $dfd_path, $pathname, $open_flags, $open_mode) = $trace_entry->{'args'} =~ $regexes{'openat2'}) {
		my $rebuild_args = false;

		printf "matched 'openat2' regex\n", if $config{'debug'} >= 1;
		if (!defined($dfd_path)) {
			$dfd_path = get_fd_path($trace_entry->{'pid'}, $dfd);
			$rebuild_args = true if ($dfd_path ne "");
		}
		if (!ret_is_error($trace_entry->{'ret'}) and my ($fd, $fd_path) = $trace_entry->{'ret'} =~ $regexes{'return_fd_path'}) {
			if ($config{'debug'} >= 2) {
				printf("  return fd: %d\n", get_match_val($fd));
				printf("  return fd path: %s\n", get_match_val($fd_path));
			}
#					$fd_path = get_atpath($pid, $dfd, $pathname) if (!defined($fd_path));
			if (!defined($fd_path)) {
				$fd_path = get_atpath($trace_entry->{'pid'}, $dfd, $pathname);
				$trace_entry->{'ret'} = sprintf("%d<%s>", $fd, $fd_path);
			}
			store_fd_name($trace_entry->{'pid'}, $fd, $fd_path);
			if ($dfd eq "AT_FDCWD" and $pathname eq "." and $fd_path ne "") {
				printf("derived CWD from openat(AT_FDCWD, \".\"...): '%s'\n", $fd_path) if ($config{'debug'} >= 1);
				set_cwd($trace_entry->{'pid'}, $fd_path);
			}
		}
		$trace_entry->{'args'} = sprintf("%s%s, \"%s\", %s%s",
			$dfd,
			(($dfd_path ne "") ? "<" . $dfd_path . ">" : ""),
			$pathname, $open_flags,
			(defined($open_mode) ? ", " . $open_mode : "")) if ($rebuild_args);
	} else {
		printf "openat2, but didn't match the re\n";
	}
}
sub syscall_dup {
	my ($trace_entry) = @_;
	if (my ($fd, $fd_path) = $trace_entry->{'args'} =~ $regexes{'dup'}) {
		my $rebuild_args = false;

		if (!defined($fd_path)) {
			$fd_path = get_fd_path($trace_entry->{'pid'}, $fd);
			$rebuild_args = true if ($fd_path ne "");
		}
		if ($rebuild_args) {
			$trace_entry->{'args'} = sprintf("%d<%s>",
				$fd, $fd_path);
		}

		if (!ret_is_error($trace_entry->{'ret'}) and my ($ret_fd, $ret_path) = $trace_entry->{'ret'} =~ $regexes{'return_fd_path'}) {
			if (!defined($ret_path) and $fd_path ne "") {
				store_fd_name($trace_entry->{'pid'}, $ret_fd, $fd_path);
				$trace_entry->{'ret'} = sprintf("%d<%s>", $ret_fd, $fd_path);
			} else {}
		} else {}
	}
}
sub syscall_dup2 {
	my ($trace_entry) = @_;
	if (my ($fd, $fd_path, $new_fd) = $trace_entry->{'args'} =~ $regexes{'dup2'}) {
		my $rebuild_args = false;

		if (!defined($fd_path)) {
			$fd_path = get_fd_path($trace_entry->{'pid'}, $fd);
			$rebuild_args = true if ($fd_path ne "");
		}
		$trace_entry->{'args'} = sprintf("%d<%s>, %s",
			$fd, $fd_path, $new_fd) if $rebuild_args;

		if (!ret_is_error($trace_entry->{'ret'}) and my ($ret_fd, $ret_path) = $trace_entry->{'ret'} =~ $regexes{'return_fd_path'}) {
			if (!defined($ret_path) and $fd_path ne "") {
				store_fd_name($trace_entry->{'pid'}, $ret_fd, $fd_path);
				$trace_entry->{'ret'} = sprintf("%d<%s>", $ret_fd, $fd_path);
			} else {}
		} else {}
	}
}
sub syscall_dup3 { # int dup3(int oldfd, int newfd, int flags);
	my ($trace_entry) = @_;
	if (my ($fd, $fd_path, $new_fd, $flags) = $trace_entry->{'args'} =~ $regexes{'dup3'}) {
		my $rebuild_args = false;

		if (!defined($fd_path)) {
			$fd_path = get_fd_path($trace_entry->{'pid'}, $fd);
			$rebuild_args = true if ($fd_path ne "");
		}
		if ($rebuild_args) {
			$trace_entry->{'args'} = sprintf("%d<%s>, %d, %s", $fd, $fd_path, $new_fd, $flags);
		}
		if (!ret_is_error($trace_entry->{'ret'}) and my ($ret_fd, $ret_path) = $trace_entry->{'ret'} =~ $regexes{'return_fd_path'}) {
			if (!defined($ret_path) and $fd_path ne "") {
				store_fd_name($trace_entry->{'pid'}, $ret_fd, $fd_path);
				$trace_entry->{'ret'} = sprintf("%d<%s>", $ret_fd, $fd_path);
			} else {}
			if ($flags =~ /O_CLOEXEC/) {
				store_cloexec_fd($trace_entry->{'pid'}, $new_fd);
			}
		}
	}
}
sub syscall_read {
#	we only care if:
#	1) we're reading from /proc/pid/cmdline
#	2) $config{'show_execnames'}
#	3) get_execname($trace_entry{'pid'}) is unknown
#	4) !ret_is_error($trace_entry{'ret'})
#	for example: read(4</proc/3644602/cmdline>, "man\0readlinkat\0", 2047) = 15
	my ($trace_entry) = @_;

	if ($config{'show_execnames'} && !ret_is_error($trace_entry->{'ret'}) && (my ($fd, $fd_path, $buf, $count) = $trace_entry->{'args'} =~ $regexes{'read'})) {
		my $rebuild_args = false;

		if (!defined($fd_path)) {
			$fd_path = get_fd_path($trace_entry->{'pid'}, $fd);
			$rebuild_args = true if ($fd_path ne "");
		}
		if ($rebuild_args) {
			$trace_entry->{'args'} = sprintf("%d%s, \"%s\", %d", $fd, (($fd_path ne "") ? "<" . $fd_path . ">" : ""),
				$buf, $count);
		}

		if (!ret_is_error($trace_entry->{'ret'}) && (my ($proc_pid) = $fd_path =~ $regexes{'proc_pid_cmdline'})) {
			$proc_pid = $trace_entry->{'pid'} if ($proc_pid eq 'self');
			my $current_pid_execname = get_execname($proc_pid);

			if ($current_pid_execname eq "") {
				if (($current_pid_execname) = $buf =~ $regexes{'proc_pid_cmdline_read'}) {
					set_execname($proc_pid, basename($current_pid_execname));
					printf("setting execname for pid %d to '%s' from reading /proc/%d/cmdline\n", $proc_pid, $current_pid_execname, $proc_pid) if ($config{'debug'} >= 2);
				}
			}
		}
	} else { # just call the regular fd function
		parse_generic_fd_function($trace_entry);
#		log_error sprintf("read syscall, but '%s' did not match the regex\n", $trace_entry->{'args'});
	}
}
sub syscall_close {
	my ($trace_entry) = @_;

	if (my ($fd, $fd_path) = $trace_entry->{'args'} =~ $regexes{'close'}) {
		printf("matched 'close' regex\n") if ($config{'debug'} >= 1);
		if ($config{'debug'} >= 2) {
			printf("%16s - %s\n", "fd", get_match_val($fd));
			printf("%16s - %s\n", "fd_path", get_match_val($fd_path));
		}
		if (!defined($fd_path)) {
			$fd_path = get_fd_path($trace_entry->{'pid'}, $fd);
			$trace_entry->{'args'} = sprintf("%d<%s>", $fd, $fd_path) if ($fd_path ne "");
		}
	} else { printf("close but didn't match the re\n"); }
}
sub syscall_mmap {
	my ($trace_entry) = @_;

	if (my ($addr, $length, $prot, $flags, $fd, $fd_path, $offset) = $trace_entry->{'args'} =~ $regexes{'mmap'}) {

		if (!defined($fd_path) and $fd >= 0) {
			$fd_path = get_fd_path($trace_entry->{'pid'}, $fd);

			if ($fd_path ne "") {
				$trace_entry->{'args'} = sprintf("%s, %s, %s, %s, %s%s, %s",
					$addr, $length, $prot, $flags, $fd,
					"<" . $fd_path . ">", $offset);
			}
		}
	} else { log_error(sprintf("mmap, but didn't match the re: '%s'\n", $regexes{'mmap'})); }
}
sub syscall_getdents {
	my ($trace_entry) = @_;
	if (my ($dfd, $dfd_path, $other_args) = $trace_entry->{'args'} =~ $regexes{'generic_function_fd'}) {
		printf("matched 'getdents' regex\n") if ($config{'debug'} >= 1);

		if ($config{'debug'} >= 2) {
			printf("%16s - %s\n", "dfd", get_match_val($dfd));
			printf("%16s - %s\n", "dfd_path", get_match_val($dfd_path));
			printf("%16s - %s\n", "other args", get_match_val($other_args));
		}

		my $current_mapping = get_fd_path($trace_entry->{'pid'}, $dfd);
		if (defined($dfd_path)) {
			store_fd_name($trace_entry->{'pid'}, $dfd, $dfd_path) if ($current_mapping eq "");
		} else {
			$trace_entry->{'args'} = sprintf("%s<%s>%s",
				$dfd, $current_mapping,
				(defined($other_args) ? ", " . $other_args : "")) if ($current_mapping ne "");
		}
	}
}
sub syscall_readlink {
	my ($trace_entry) = @_;
#	if ($config{'show_execnames'} && !ret_is_error($trace_entry->{'ret'}) && (my ($proc_pid, $link_target) = $trace_entry->{'args'} =~ $regexes{'readlink'})) {
	if (!ret_is_error($trace_entry->{'ret'}) && (my ($proc_pid, $link_target) = $trace_entry->{'args'} =~ $regexes{'readlink'})) {
		$proc_pid = $trace_entry->{'pid'} if ($proc_pid eq 'self');
		printf("found a readlink for pid " . $proc_pid . " to %s\n", $link_target) if ($config{'debug'} >= 2);

		my $current_execname = get_execname($proc_pid);
		printf("pid %d - current execname: %s, execname from readlink: %s\n", $proc_pid, $current_execname, basename($link_target)) if ($config{'debug'} >= 2);

		if ($current_execname eq "") {
			printf("setting execname for pid %d to '%s'\n", $proc_pid, basename($link_target)) if ($config{'debug'} >= 1);
		}

		set_execname($proc_pid, basename($link_target)) if ($current_execname eq "");
	}
}
sub syscall_pipe {
	my ($trace_entry) = @_;

	printf("matched pipe\n") if ($config{'debug'} >= 1);
	if (my ($fd0, $fd0_name, $fd1, $fd1_name) = $trace_entry->{'args'} =~ $regexes{'pipe'}) {
		my $rebuild_args = false;

		my $pid_string = (defined($trace_entry->{'pid'}) && $trace_entry->{'pid'} ne -1) ? sprintf("pid_%d_", $trace_entry->{'pid'}) : "";

		if (!defined($fd0_name)) {
			$fd0_name = sprintf("%spipe_%d-%d_in", $pid_string, $fd0, $fd1);
			$rebuild_args = true;
		}
		if (!defined($fd1_name)) {
			$fd1_name = sprintf("%spipe_%d-%d_out", $pid_string, $fd0, $fd1);
			$rebuild_args = true;
		}
		store_fd_name($trace_entry->{'pid'}, $fd0, $fd0_name);
		store_fd_name($trace_entry->{'pid'}, $fd1, $fd1_name);
		if ($rebuild_args) {
			$trace_entry->{'args'} = sprintf("[%d<%s>, %d<%s>]",
				$fd0, $fd0_name, $fd1, $fd1_name);
		}
	} else { printf("didn't match pipe regex: %s\n", $regexes{'pipe'}); };
}
sub syscall_socket {
	my ($trace_entry) = @_;

	my ($fd, $fd_name);
#			21:21:51 socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 19

	printf("matched socket\n") if ($config{'debug'} >= 1);

#printf "socket_domain: %s\n", $patterns{'socket_domain'};
#printf "socket_type: %s\n", $patterns{'socket_type'};
#printf "socket_proto: %s\n", $patterns{'socket_proto'};
#printf "args: %s\n", $trace_entry->{'args'};
#printf "socket regex: %s\n", $regexes{'socket'};

#	'socket' => qr/^($patterns{'socket_domain'}), ($patterns{'socket_type'}), ($patterns{'socket_proto'})$/,

	if (!ret_is_error($trace_entry->{'ret'}) && (($fd, $fd_name) = $trace_entry->{'ret'} =~ $regexes{'socket_ret'})) {
		if (!defined($fd_name) && ((my ($socket_domain, $socket_type, $socket_proto) = $trace_entry->{'args'} =~ $regexes{'socket'}))) {
			my $pid_string = (defined($trace_entry->{'pid'}) && $trace_entry->{'pid'} ne -1) ? sprintf("pid_%d_", $trace_entry->{'pid'}) : "";
			$socket_type =~ s/(\|SOCK_(CLOEXEC|NONBLOCK))//g;

			$fd_name = sprintf("%ssocket_%s:%s%s", $pid_string, $socket_domain,
				$socket_type, ($socket_proto eq "0" ? "" : ":" . $socket_proto));

			$trace_entry->{'ret'} = sprintf("%d<%s>", $trace_entry->{'ret'}, $fd_name);
		}
		store_fd_name($trace_entry->{'pid'}, $fd, $fd_name);
#		printf "stored socket fd %d name %s\n", $trace_entry->{'ret'}, $fd_name if ($config{'debug'} >= 1);
		printf "stored socket fd %d name %s\n", $fd, $fd_name if ($config{'debug'} >= 1);
	} elsif (!ret_is_error($trace_entry->{'ret'})) { printf("didn't match socket regex: %s\n", $regexes{'socket'}); }
}
sub syscall_socketpair {
	my ($trace_entry) = @_;
	printf("matched socketpair\n") if ($config{'debug'} >= 1);
	if (my ($af_name, $sock_type, $sock_proto, $fd0, $fd0_name, $fd1, $fd1_name) = $trace_entry->{'args'} =~ $regexes{'socketpair'}) {
		my $rebuild_args = false;

		my $pid_string = (defined($trace_entry->{'pid'}) && $trace_entry->{'pid'} ne -1) ? sprintf("pid_%d_", $trace_entry->{'pid'}) : "";

if (0) { # TODO - fix parsing the socket strings
		if (!defined($fd0_name)) {
			$fd0_name = sprintf("%ssocket_%d-%d_in", $pid_string, $fd0, $fd1);
			$rebuild_args = true;
		}
		if (!defined($fd1_name)) {
			$fd1_name = sprintf("%ssocket_%d-%d_out", $pid_string, $fd0, $fd1);
			$rebuild_args = true;
		}
		store_fd_name($trace_entry->{'pid'}, $fd0, $fd0_name);
		store_fd_name($trace_entry->{'pid'}, $fd1, $fd1_name);
		if ($rebuild_args) {
			$trace_entry->{'args'} = sprintf("[%d<%s>, %d<%s>]",
				$fd0, $fd0_name, $fd1, $fd1_name);
		}
}
	} else { printf("didn't match socketpair regex: %s\n", $regexes{'socketpair'}); };
}
sub syscall_timerfd_create {
	my ($trace_entry) = @_;
	if (!ret_is_error($trace_entry->{'ret'})) {
		if (my ($fd, $fd_string) = $trace_entry->{'ret'} =~ $regexes{'return_fd_path'}) {
			if (!defined($fd_string)) {
				$fd_string= sprintf("pid_%d_timerfd_%d", $trace_entry->{'pid'}, $fd);
				$trace_entry->{'ret'} = sprintf("%d<%s>", $fd, $fd_string);
			}
			if (my ($clockid, $timerfd_flags) = $trace_entry->{'args'} =~ $regexes{'timerfd_create'}) {
				printf("timerfd_flags: %s\n", $timerfd_flags) if ($config{'debug'} >= 2);
				if (grep { $_ eq 'TFD_CLOEXEC' } split('\|', $timerfd_flags)) {
					printf("timerfd_create setting cloexec\n") if ($config{'debug'} >= 2);
					store_cloexec_fd($trace_entry->{'pid'}, $fd);
				} else { }
			}
		}
	}
}
sub syscall_epoll_create1 {
	my ($trace_entry) = @_;
	if (!ret_is_error($trace_entry->{'ret'})) {
		if (my ($fd, $fd_string) = $trace_entry->{'ret'} =~ $regexes{'return_fd_path'}) {

			printf("epoll_create1 fd: %d, fd_string: %s\n", $fd, $fd_string) if ($config{'debug'} >= 1);
			if (!defined($fd_string)) {
				$fd_string = sprintf("pid_%d_eventpoll_fd_%d", $trace_entry->{'pid'}, $fd);
				$trace_entry->{'ret'} = sprintf("%d<%s>", $fd, $fd_string);
			}
			store_fd_name($trace_entry->{'pid'}, $fd, $fd_string);
			if ($trace_entry->{'syscall'} eq 'epoll_create1') {
				store_cloexec_fd($trace_entry->{'pid'}, $fd) if ($trace_entry->{'args'} eq 'EPOLL_CLOEXEC' || $trace_entry->{'args'} eq '' . oct('02000000'));
			}
		}
	}
}
sub syscall_eventfd2 {
	my ($trace_entry) = @_;
	if (!ret_is_error($trace_entry->{'ret'})) {
		if (my ($fd, $fd_string) = $trace_entry->{'ret'} =~ $regexes{'return_fd_path'}) {

			printf("eventfd2 fd: %d, fd_string: %s\n", $fd, $fd_string) if ($config{'debug'} >= 1);
			if (!defined($fd_string)) {
				$fd_string = sprintf("pid_%d_eventfd2_fd_%d", $trace_entry->{'pid'}, $fd);
				$trace_entry->{'ret'} = sprintf("%d<%s>", $fd, $fd_string);
			}
			store_fd_name($trace_entry->{'pid'}, $fd, $fd_string);
			if ($trace_entry->{'syscall'} eq 'eventfd2') {
				store_cloexec_fd($trace_entry->{'pid'}, $fd) if ($trace_entry->{'args'} eq 'EPOLL_CLOEXEC' || $trace_entry->{'args'} eq '' . oct('02000000'));
			}
		}
	}
}
sub syscall_fcntl {
	my ($trace_entry) = @_;
	my $rebuild_args = false;

	printf("fcntl regex\n") if ($config{'debug'} >= 1);
	if (my ($fd, $fd_path, $fcntl_cmd, $other_args) = $trace_entry->{'args'} =~ $regexes{'fcntl'}) {

		if ($config{'debug'} >= 2) {
			printf("fd: %d\n", $fd);
			printf("fd_path: %s\n", get_match_val($fd_path));
			printf("fcntl_cmd: %s\n", $fcntl_cmd);
			printf("other args: %s\n", get_match_val($other_args));
		}

		if (!defined($fd_path)) {
			$fd_path = get_fd_path($trace_entry->{'pid'}, $fd);
			$rebuild_args = true if ($fd_path ne "");
		}

		if ($fcntl_cmd eq "F_DUPFD" or $fcntl_cmd eq "F_DUPFD_CLOEXEC") {
			if (!ret_is_error($trace_entry->{'ret'}) and my ($ret_fd, $ret_path) = $trace_entry->{'ret'} =~ $regexes{'return_fd_path'}) {
				if (!defined($ret_path) and $fd_path ne "") {
#					$ret_path = $fd_path;
					store_fd_name($trace_entry->{'pid'}, $ret_fd, $fd_path);
					$trace_entry->{'ret'} = sprintf("%d<%s>", $ret_fd, $fd_path);
				} else {
				}
			} else {
			}
		} elsif (grep { $_ eq $fcntl_cmd } ( "F_GETLK", "F_SETLK", "F_SETLKW", "F_OFD_GETLK", "F_OFD_SETLK", "F_OFD_SETLKW" )) {
		} elsif (grep { $_ eq $fcntl_cmd } ( "F_GETFL", "F_SETFL", "F_GETFD", "F_SETFD")) {
		} elsif (grep { $_ eq $fcntl_cmd } ( "F_GETPIPE_SZ", "F_SETPIPE_SZ")) {
		} else {
			printf("fcntl cmd didn't match anything: '%s'\n", $fcntl_cmd);
		}
		if ($rebuild_args) {
			$trace_entry->{'args'} = sprintf("%d<%s>, %s%s",
				$fd, $fd_path, $fcntl_cmd,
				(defined($other_args) ? ", " . $other_args : ""));
		}
	}
}
sub syscall_renameat {
	my ($trace_entry) = @_;

	if (my ($dfd0, $dfd0_path, $path0, $dfd1, $dfd1_path, $path1, $flags) = $trace_entry->{'args'} =~ $regexes{'renameat'}) {
		my $rebuild_args = false;

		if (!defined($dfd0_path)) {
			$dfd0_path = get_fd_path($trace_entry->{'pid'}, $dfd0);
			$rebuild_args = true if ($dfd0_path ne "");
		}
		if (!defined($dfd1_path)) {
			$dfd1_path = get_fd_path($trace_entry->{'pid'}, $dfd1);
			$rebuild_args = true if ($dfd1_path ne "");
		}

		if ($rebuild_args) {
#			$trace_entry->{'args'} = sprintf("%s%s, \"%s\"%s, %s%s, \"%s\"%s%s",
			# AT_FDCWD, "/wps/exports_P85/PROD/empcatRelease.xml", AT_FDCWD, "/wps/exports_P85/PROD/empcatRelease20220207154004.xml", 0) = 0 <0.003260>

			$trace_entry->{'args'} = sprintf("%s%s, \"%s\", %s%s, \"%s\"%s",
				$dfd0, $dfd0_path ne "" ? "<" . $dfd0_path . ">" : "", $path0,
				$dfd1, $dfd1_path ne "" ? "<" . $dfd1_path . ">" : "", $path1,
				defined $flags ? ", " . $flags : "");
		}
	} else { printf("renameat(2) syscall, but args '%s' didn't match the regex '%s'\n", $trace_entry->{'args'}, $regexes{'renameat'}); }
}
sub syscall_inotify_init {
	my ($trace_entry) = @_;
	# int inotify_init(void);
	# int inotify_init1(int flags);
#469426 1655778774.508576 inotify_init1(IN_CLOEXEC) = 18<anon_inode:inotify> <0.000054>
	if (my ($flags) = $trace_entry->{'args'} =~ /^(.+)?$/) {
		$flags = defined_or_default($flags, ""); # if set, may be IN_NONBLOCK|IN_CLOEXEC
		if (! defined $flags) { $flags = "" };

		if (!ret_is_error($trace_entry->{'ret'}) and my ($fd, $fd_path) = $trace_entry->{'ret'} =~ $regexes{'return_fd_path'}) {
			store_cloexec_fd($trace_entry->{'pid'}, $fd) if ($flags =~ /\bIN_CLOEXEC\b/);
			if (!defined($fd_path) || $fd_path eq "") {
				$fd_path = "anon_inode:inotofy";
				$trace_entry->{'ret'} = sprintf("%d<%s>", $fd, $fd_path);
			}
			store_fd_name($trace_entry->{'pid'}, $fd, $fd_path);
		} else {
			printf "did not match the return_fd_path\n";
		}
	} else {
		printf("inotify_init, but didn't match the re for args '%s'\n", $trace_entry->{'args'});
	}
}
sub syscall_chroot {
	my ($trace_entry) = @_;

	if (!ret_is_error($trace_entry->{'ret'}) and my ($chroot_path) = $trace_entry->{'args'} =~ $regexes{'chroot'}) {
		# TODO: track chroot path
	}
}

sub syscall_execve {
	my ($trace_entry) = @_;

	# only meaningful if the execve is successful
	if (!ret_is_error($trace_entry->{'ret'}) and my ($execve_path, $execve_argv, $execve_envp) = $trace_entry->{'args'} =~ $regexes{'execve'}) {
#		$trace_entry->{'this_line_execname'} = get_execname($trace_entry->{'pid'}) if ($config{'show_execnames'} && $trace_entry->{'this_line_execname'} eq "");


		if ($trace_entry->{'this_line_execname'} eq "") {
			$trace_entry->{'this_line_execname'} = get_execname($trace_entry->{'pid'});
			set_execname($trace_entry->{'pid'}, basename($execve_path));
			pidtree_new_cmd($trace_entry->{'pid'}, basename($execve_path));
		}
		printf("execve_path %s\nargv: %s\n", $execve_path, $execve_argv) if ($config{'debug'} >= 1);

		if (get_cwd($trace_entry->{'pid'}) eq "" && (my ($args1, $exec_pwd, $args2) = $execve_envp =~ $regexes{'execve_pwd_path'})) {
			set_cwd($trace_entry->{'pid'}, $exec_pwd);
			printf("in execve(), environment variable PWD is '%s'; setting cwd\n",
				$exec_pwd) if ($config{'debug'} >= 1);
		}
	# TODO - clear the CLOEXEC fds
	# duplicate the fd table, if the process was cloned with CLONE_FILES (table is shared)
	} elsif (ret_is_error($trace_entry->{'ret'})) { # unsuccessful execve
	} else {
		printf "'%s' did not match 'execve' regex: %s\n", $trace_entry->{'args'}, $regexes{'execve'};
	}
}
sub syscall_clone {
	my ($trace_entry) = @_;

	# if CLONE_FILES is set, the two processes SHARE fd table
	# if execve is later called, the fd table is duplicated, and no longer shared
#printf("clone args *%s*\n", $trace_entry->{'args'});
	if (my ($flags) = $trace_entry->{'args'} =~ $regexes{'clone'}) {
		printf("clone flags: %s\n", $flags) if ($config{'debug'} >= 1);

		if (!ret_is_error($trace_entry->{'ret'})) {
			if ($flags =~ /CLONE_FILES/) {
				store_shared_fd_table_mapping($trace_entry->{'ret'}, $trace_entry->{'pid'});
			} else {
				inherit_fd_table($trace_entry->{'ret'}, $trace_entry->{'pid'});
			}
			set_execname($trace_entry->{'ret'}, get_execname($trace_entry->{'pid'}));

			pidtree_add_child($trace_entry->{'pid'}, $trace_entry->{'ret'}, get_execname($trace_entry->{'pid'}));
		}
	} else { printf("clone didn't match regex\n"); }
}
sub syscall_clone3 {
	my ($trace_entry) = @_;

	# if CLONE_FILES is set, the two processes SHARE fd table
	# if execve is later called, the fd table is duplicated, and no longer shared
#printf("clone args *%s*\n", $trace_entry->{'args'});
	if (my ($clone3_args1, $clone3_args2, $size) = $trace_entry->{'args'} =~ $regexes{'clone3'}) {
#		printf("clone flags: %s\n", $flags) if ($config{'debug'} >= 1);

		if (!ret_is_error($trace_entry->{'ret'})) {
			if ($clone3_args1 =~ /CLONE_FILES/) {
				store_shared_fd_table_mapping($trace_entry->{'ret'}, $trace_entry->{'pid'});
			} else {
				inherit_fd_table($trace_entry->{'ret'}, $trace_entry->{'pid'});
			}
			set_execname($trace_entry->{'ret'}, get_execname($trace_entry->{'pid'}));

			pidtree_add_child($trace_entry->{'pid'}, $trace_entry->{'ret'}, get_execname($trace_entry->{'pid'}));
		}
#	} else { printf("clone3 didn't match regex\n"); }
	} else { # TODO: fix this regex
	}
}
sub syscall_vfork {
	my ($trace_entry) = @_;

	if (!ret_is_error($trace_entry->{'ret'})) {
		set_execname($trace_entry->{'ret'}, get_execname($trace_entry->{'pid'}));
		set_cwd($trace_entry->{'ret'}, get_cwd($trace_entry->{'pid'}));
		inherit_fd_table($trace_entry->{'ret'}, $trace_entry->{'pid'});

		pidtree_add_child($trace_entry->{'pid'}, $trace_entry->{'ret'}, get_execname($trace_entry->{'pid'}));
	} else { }
}
sub syscall_exit { # TODO: what about exit_group?
	my ($trace_entry) = @_;

	# TODO: find other pids sharing this fd_table, and duplicate the fd table for them (or would we re-parent the shared table?)
	clear_fd_table($trace_entry->{'pid'});
}
sub syscall_kill {
	my ($trace_entry) = @_;

	if (my ($kill_pid, $kill_pid_name, $kill_sig) = $trace_entry->{'args'} =~ $regexes{'kill'}) {
		my $rebuild_args = false;
		my $kill_group = ($kill_pid < -1) ? true : false;

		# If pid is positive, then signal sig is sent to the process with the ID specified by pid.
		# If pid equals 0, then sig is sent to every process in the process group of the calling process.
		#  equals -1, then sig is sent to every process for which the calling process has permission to send signals, except for process 1 (init), but see below.
		#  is less than -1, then sig is sent to every process in the process group whose ID is -pid.
		#  is 0, then no signal is sent, but existence and permission checks are still performed; this can be used to check for the existence of a process ID or process group ID that the caller is permitted to signal.
		$kill_pid = (0 - $kill_pid) if ($kill_group);

		if (defined($kill_pid_name) && $kill_pid_name ne "") {
			set_execname($kill_pid, $kill_pid_name) if (get_execname($kill_pid) eq "");
#			$rebuild_args = true if (!$config{'show_execnames'});
			$rebuild_args = true;
#		} elsif ($config{'show_execnames'}) {
		} else {
			$kill_pid_name = get_execname($kill_pid);
			$rebuild_args = true;
		}
		if ($kill_sig =~ /\d+$/ && defined($sig_names{$kill_sig})) {
#			$kill_sig = "" . $kill_sig . " (" . $sig_names{$kill_sig} . ")";
			$kill_sig = $sig_names{$kill_sig};
			$rebuild_args = true;
		}
		if ($rebuild_args) {
			$trace_entry->{'args'} = $kill_group ? '-' : '' . $kill_pid .
				($kill_pid_name ne "" ? " (" . $kill_pid_name . ")" : "") .
				", " . $kill_sig;
#				(($config{'show_execnames'} && $kill_pid_name ne "") ? " (" . $kill_pid_name . ")" : "") .
		}
	} else {
		printf("couldn't match regex '%s' to args '%s'\n", $regexes{'kill'}, $trace_entry->{'args'});
	}
}

%syscall_functions = (
	'getcwd' => \&syscall_getcwd,
	'chdir' => \&syscall_chdir,
	'fchdir' => \&syscall_fchdir,
	'creat' => \&syscall_creat,
	'open' => \&syscall_open,
	'openat' => \&syscall_openat,
	'openat2' => \&syscall_openat2,
	'close' => \&syscall_close,
	'mmap' => \&syscall_mmap,
	'fcntl' => \&syscall_fcntl,
	'dup' => \&syscall_dup,
	'dup2' => \&syscall_dup2,
	'dup3' => \&syscall_dup3,

	'renameat' => \&syscall_renameat,
	'renameat2' => \&syscall_renameat,

	'getdents' => \&syscall_getdents,
	'getdents64' => \&syscall_getdents,

	'read' => \&syscall_read,
	'readlink' => \&syscall_readlink,
	'pipe' => \&syscall_pipe,
	'socket' => \&syscall_socket,
	'socketpair' => \&syscall_socketpair,
	'timerfd_create' => \&syscall_timerfd_create,
	'epoll_create1' => \&syscall_epoll_create1,
	'eventfd2' => \&syscall_eventfd2,

	'inotify_init' => \&syscall_inotify_init,
	'inotify_init1' => \&syscall_inotify_init,

	'chroot' => \&syscall_chroot,

	'execve' => \&syscall_execve,
	'vfork' => \&syscall_vfork,
	'clone' => \&syscall_clone,
	'clone3' => \&syscall_clone3,
	'exit'	=> \&syscall_exit,
	'kill' => \&syscall_kill,

);

# TODO: queue 
sub output_trace_entry {
	my ($trace_entry) = @_;

	printf("%s\n", $trace_entry->{'line'});
}
sub flush_trace_entries {
}

sub display_pidtree {
	my %visited = ();

	local *_print_one_pid = sub {
		my $pid = $_[0];
		my $indent = $_[1];
		my $cmd = $tracking_data{'pid_tree'}{'cmds'}{$pid};
		my $tmp_cmd = get_execname($pid);
		$cmd = $tmp_cmd if ($cmd eq "" && defined $tmp_cmd && $tmp_cmd ne "");
		$cmd = "unknown" if ($cmd eq "");

#		my @cmd_history = @{$tracking_data{'pid_tree'}{'cmd_history'}{$pid}};
		my @cmd_history = @{$tracking_data{'pid_stats'}{'pid'}{$pid}{'cmd_history'}};
		if (scalar @cmd_history > 1) {
			printf "%6d%s\\_ %-.40s  (%s)\n", $pid, $indent,
			$cmd, join(',', @cmd_history);
		} else {
			printf "%6d%s\\_ %-.40s\n", $pid, $indent,
			$cmd;
		}
	};
	local *_display_pidtree = sub {
		my $ppid = $_[0];
		my $pid = $_[1];
		my $indent = $_[2];
		my $more_children = $_[3];
		my $temp = "";

		return if (defined($visited{$pid}) && $visited{$pid});

		if (!defined $tracking_data{'pid_tree'}{'tree'}{$ppid}{$pid}) {
			printf "ppid: %d, pid: %d\n", $ppid, $pid;
			exit;
		}

		_print_one_pid($pid, $indent);
		$visited{$pid} = 1;
		my $child_counter = keys(%{$tracking_data{'pid_tree'}{'tree'}{$pid}});

		$temp = $indent . (($more_children > 0 && $child_counter > 0) ? "|" : " ") . "   ";
		my @child_pids = sort(keys(%{$tracking_data{'pid_tree'}{'tree'}{$pid}}));
		for my $child_pid (@child_pids) {
			$child_counter --;
			_display_pidtree($pid, $child_pid, $temp, $child_counter);
		}
	};
	printf "   PID  COMMAND\n";
#print Dumper($tracking_data{'pid_tree'});
	my @tlpids = sort(keys %{$tracking_data{'pid_tree'}{'tlpids'}});

	foreach my $tlpid (@tlpids) {
		if (!defined $tracking_data{'pid_tree'}{'cmds'}{$tlpid}) {
			printf "why is cmds->%d not set?\n", $tlpid;
		}
		_print_one_pid($tlpid, "");

		my @child_pids = sort(keys(%{$tracking_data{'pid_tree'}{'tree'}{$tlpid}}));
		my $child_counter = scalar @child_pids;

		for my $pid (@child_pids) {
			$child_counter--;
			_display_pidtree($tlpid, $pid, "  ", $child_counter);
		}
	}
}

# success returns nonzero
sub parse_syscall {
	my ($trace_entry) = @_;

	if (defined($syscall_functions{$trace_entry->{'syscall'}})) {
		$syscall_functions{$trace_entry->{'syscall'}}->($trace_entry);

		return true;
	}
	return false;
}
sub parse_generic_fd_function {
	my ($trace_entry) = @_;
	printf("generic fd function: %s\n", $trace_entry->{'syscall'}) if ($config{'debug'} >= 1);

	if (my ($fd, $fd_path, $other_args) = $trace_entry->{'args'} =~ $regexes{'generic_function_fd'}) {
		my $rebuild_args = false;

		if (!defined($fd_path)) {
			$fd_path = get_fd_path($trace_entry->{'pid'}, $fd);
			$rebuild_args = true if ($fd_path ne "");
		}
		if ($rebuild_args) {
			$trace_entry->{'args'} = sprintf("%d%s%s",
				$fd,
				(($fd_path ne "") ? "<" . $fd_path . ">" : ""),
				(defined($other_args) ? ", " . $other_args : ""));
		}
	} else { printf("generic %s(fd...), but '%s' didn't match the regex: %s\n", $trace_entry->{'syscall'}, $trace_entry->{'args'}, $regexes{'generic_function_fd'}); }
}
sub parse_generic_dfd_path_function {
	my ($trace_entry) = @_;
	printf("generic dfd+path function: %s\n", $trace_entry->{'args'}) if ($config{'debug'} >= 1);

	if (my ($dfd, $dfd_path, $this_path_or_null, $path, $other_args) = $trace_entry->{'args'} =~ $regexes{'generic_function_dfd_path'}) {
		my $rebuild_args = false;

		if (!defined($dfd_path)) {
			$dfd_path = get_fd_path($trace_entry->{'pid'}, $dfd);
			$rebuild_args = true if ($dfd_path ne "");
		}
		if ($rebuild_args) {
			$trace_entry->{'args'} = sprintf("%s%s, %s%s",
				$dfd,
				(($dfd_path ne "") ? "<" . $dfd_path . ">" : ""),
				$this_path_or_null,
				(defined($other_args) ? ", " . $other_args : ""));
		}
	} else {
		log_error(sprintf("generic %s(dfd, path...), but '%s' didn't match the regex '%s'\n", $trace_entry->{'syscall'}, $trace_entry->{'args'}, $regexes{'generic_function_dfd_path'}));
	}
}
sub myopen {
	open my $fh, "@_" or die "blah: $!\n";
	return $fh;
}
##### pcap-generation #####
use constant {
        CALL => 1,
        COMPLETION => 2,
};

use constant {
        EPB_HEADER_LEN => 9*4, # 9*4 + any options size
        ETH_HEADER_LEN => 14, # 2x eth addrs + 4-byte type
        IP_HEADER_LEN => 20,
        UDP_HEADER_LEN => 8,
};

# linktypes
use constant {
        LINKTYPE_ETH => 1,
        LINKTYPE_DLT_RAW => 101,
};

my $pcap_queued_bytes = '';
my $pcap_queued_len = 0;

use constant {
        SHB => 0x0a0d0d0a,
        IDB => 0x00000001,
#       PB => 0x00000002, # obsolete
        SPB => 0x00000003,
        NRB => 0x00000004,
        ISB => 0x00000005,
        EPB => 0x00000006,
#       SDJ => 0x00000009,
#       DSB => 0x0000000a, # also 'ZigBee NWK Key Data', 'ZigBee APS Key Data'
        CB => 0x00000bad,
        CB2 => 0x40000bad,
};
#   IDB - interface description block
#   EPB - enhanced packet block
#   SPB - simple packet block
#   NRB - name resolution block
#   ISB - interface statistics block
#   CB - custom block
#      - systemd Journal Export Block
#   DSB - Decryption Secrets Block
my %pcap_config = (
        'program_name' => "",
        'subsec_digits' => 6,
        'linktype' => LINKTYPE_DLT_RAW,
        'src_ip' => 0x7f000001,
        'dst_ip' => 0x7f000001,
        'dst_ip_call' => 0x7f000001,
        'dst_ip_completion' => 0x7f000002,
);
sub pcap_calc_pad_bytes { ($_[0] % 4 == 0) ? 0 : 4 - ($_[0] % 4); }
sub pcap_print_pad_bytes {
        my $len = shift;
        for (my $i = 0 ; $i < $len ; $i++) {
                printf("%c", 0);
        }
}
sub bytes_u8 { return (chr($_[0] & 0xff)); }
sub bytes_u16 { return (chr(($_[0] >> 8) & 0xff) . chr($_[0] & 0xff)); }
sub bytes_u32 { return (chr(($_[0] >> 24) & 0xff) . chr(($_[0] >> 16) & 0xff) .
        chr(($_[0] >> 8) & 0xff) . chr($_[0] & 0xff)); }
sub bytes_u64 { bytes_u32($_[0] >> 32) . bytes_u32($_[0] & 0xffffffff); }

sub pcap_print_u8 {
        my $val = shift;

        printf("%c", $val & 0xff);
}
sub pcap_print_u16 {
        my $val = shift;

        printf("%c%c", $val & 0xff, ($val >> 8) & 0xff);
}
sub pcap_print_u32 {
        my $val = shift;

        printf("%c%c%c%c",
                $val & 0xff, ($val >> 8) & 0xff,
                ($val >> 16) & 0xff, ($val >> 24) & 0xff);
}
sub pcap_output_queued {
        printf STDERR "queued len: %d (%x) - writing %d (%x), count of queued bytes: %d (%x)\n",
        $pcap_queued_len, $pcap_queued_len,
        $pcap_queued_len + 12, $pcap_queued_len + 12,
        length($pcap_queued_bytes), length($pcap_queued_bytes) if ($config{'debug'} >= 1);

        pcap_print_u32($pcap_queued_len + 12);
        for (my $i = 0 ; $i < $pcap_queued_len ; $i++) {
                printf("%c", ord(substr($pcap_queued_bytes, $i, 1)) & 0xff);
        }
        pcap_print_pad_bytes(calc_pad_bytes($pcap_queued_len));
        pcap_print_u32($pcap_queued_len + 12);
        $pcap_queued_bytes = '';
        $pcap_queued_len = 0;
}
sub pcap_queue_u8 {
        $pcap_queued_bytes .= chr(int($_[0]) & 0xff);
        $pcap_queued_len++;
        printf STDERR "queued 1 byte\n" if ($config{'debug'} >= 1);
}
sub pcap_queue_u16 {
        my $val = shift;

        $pcap_queued_bytes .= sprintf("%c%c", $val & 0xff, ($val >> 8) & 0xff);
        $pcap_queued_len += 2;
        printf STDERR "queued 2 bytes\n" if ($config{'debug'} >= 1);
}
sub pcap_queue_u32 {
        my $val = shift;

        $pcap_queued_bytes .= sprintf("%c%c%c%c",
                $val & 0xff, ($val >> 8) & 0xff,
                ($val >> 16) & 0xff, ($val >> 24) & 0xff);
        $pcap_queued_len += 4;
        printf STDERR "queued 4 bytes\n" if ($config{'debug'} >= 1);
}
sub pcap_queue_u64 {
        my $val = shift;

        pcap_queue_u32($val & 0xffffffff);
        pcap_queue_u32(($val >> 32) & 0xffffffff);
        printf STDERR "queued 8 bytes\n" if ($config{'debug'} > 1);
}
sub pcap_queue_bytes {
        my $val = shift;
        my $len = length($val);

        for (my $i = 0 ; $i < $len ; $i++) {
                $pcap_queued_bytes .= sprintf("%c", ord(substr($val, $i, 1)) & 0xff);
                $pcap_queued_len++;
        }
        printf STDERR "queued %d bytes\n", $len if ($config{'debug'} >= 1);
}
sub pcap_queue_pad_bytes {
        my $len = shift;
        for (my $i = 0 ; $i < $len ; $i++) {
                $pcap_queued_bytes .= sprintf("%c", 0);
                $pcap_queued_len++;
        }
        printf STDERR "queued %d pad bytes\n", $len if ($config{'debug'} >= 1);
}
sub pcap_queue_end_of_options {
        pcap_queue_u16(0); # opt_endofopt = 0
        pcap_queue_u16(0); # option length = 0
}
# magic (32 bits)
sub pcap_print_magic { print_u32(SHB); }
# byte order magic (32 bits)
# 0x1a2b3c4d by endian
sub pcap_queue_byte_order_magic {
        $pcap_queued_bytes .= sprintf("%c%c%c%c", 0x4d, 0x3c, 0x2b, 0x1a);
        $pcap_queued_len += 4;
}
# major version (16 bits)
# minor version (16 bits)
sub pcap_queue_version {
	my $maj = shift;
	my $min = shift;

	pcap_queue_u16($maj);
	pcap_queue_u16($min);
}
# SECTION (pcapng file) HEADER BLOCK
#
# from https://github.com/pcapng/pcapng/blob/master/reference-draft-tuexen-opsawg-pcapng.xml

#    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 0 |                   Block Type = 0x0A0D0D0A                     |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 4 |                      Block Total Length                       |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 8 |                      Byte-Order Magic                         |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#12 |          Major Version        |         Minor Version         |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#16 |                                                               |
#   |                          Section Length                       |
#   |                                                               |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#24 /                                                               /
#   /                      Options (variable)                       /
#   /                                                               /
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#   |                      Block Total Length                       |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# SHB - mandatory; must appear at least once in each file
# optional blocks:
#   IDB - interface description block
#   EPB - enhanced packet block
#   SPB - simple packet block
#   NRB - name resolution block
#   ISB - interface statistics block
#   CB - custom block
#      - systemd Journal Export Block
#   DSB - Decryption Secrets Block
#

# options
#       opt_endofopt - code: 0; length: 0
#       opt_comment - code: 1; length: variable
#
# section header block options
#       2 - shb_hardware  - variable length
#       3 - shb_os        - variable length
#       4 - shb_userappl  - variable length
#
#
# interface description block
#                        1                   2                   3
#    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 0 |                    Block Type = 0x00000001                    |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 4 |                      Block Total Length                       |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 8 |           LinkType            |           Reserved            |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#12 |                            SnapLen                            |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#16 /                                                               /
#   /                      Options (variable)                       /
#   /                                                               /
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#   |                      Block Total Length                       |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# Interface Description Block options'
#       3 - if_description (variable)
#       4 - if_IPv4addr (8 bytes)
#       5 - if_IPv6addr (17 bytes)
#       6 - if_MACaddr (8 bytes)
#       7 - if_EUIaddr (8 bytes)
#       8 - if_speed (8 bytes)
#       9 - if_tsresol (1 byte)
#       10 - if_tzone (4 bytes)
#       11 - if_filter (variable, minimum 1)
#       12 - if_os (variable)
#       13 - if_fcslen (1 byte)
#       14 - if_tsoffset (8 bytes)
#       15 - if_hardware (variable)
#       16 - if_txspeed (8 bytes)
#       17 - if_rxspeed (8 bytes)

# Enhanced Packet Block
#                        1                   2                   3
#    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 0 |                    Block Type = 0x00000006                    |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 4 |                      Block Total Length                       |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 8 |                         Interface ID                          |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#12 |                        Timestamp (High)                       |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#16 |                        Timestamp (Low)                        |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#20 |                    Captured Packet Length                     |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#24 |                    Original Packet Length                     |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#28 /                                                               /
#   /                          Packet Data                          /
#   /              variable length, padded to 32 bits               /
#   /                                                               /
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#   /                                                               /
#   /                      Options (variable)                       /
#   /                                                               /
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#   |                      Block Total Length                       |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Table 4: Enhanced Packet Block Options
# Name          Code    Length                  Multiple allowed?
# epb_flags     2       4                       no
# epb_hash      3       variable, minimum hash type-dependent   yes
# epb_dropcount 4       8                       no
# epb_packetid  5       8                       no
# epb_queue     6       4                       no
# epb_verdict   7       variable, minimum verdict type-dependent        yes


# Simple Packet Block
#                        1                   2                   3
#    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 0 |                    Block Type = 0x00000003                    |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 4 |                      Block Total Length                       |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 8 |                    Original Packet Length                     |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#12 /                                                               /
#   /                          Packet Data                          /
#   /              variable length, padded to 32 bits               /
#   /                                                               /
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#   |                      Block Total Length                       |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Name Resolution Block
#                        1                   2                   3
#    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 0 |                    Block Type = 0x00000004                    |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 4 |                      Block Total Length                       |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 8 |      Record Type              |      Record Value Length      |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#12 /                       Record Value                            /
#   /              variable length, padded to 32 bits               /
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#   .                                                               .
#   .                  . . . other records . . .                    .
#   .                                                               .
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#   |  Record Type = nrb_record_end |   Record Value Length = 0     |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#   /                                                               /
#   /                      Options (variable)                       /
#   /                                                               /
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#   |                      Block Total Length                       |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Name                  Code    Length
#nrb_record_end         0x0000  0
#nrb_record_ipv4        0x0001  variable
#nrb_record_ipv6        0x0002  variable

# Table 7: Name Resolution Block Options
# Name  Code    Length  Multiple allowed?
# ns_dnsname    2       variable        no
# ns_dnsIP4addr 3       4       no
# ns_dnsIP6addr 4       16      no

sub pcap_queue_option_varlen {
        my $id = shift;
        my $val = shift;
        my $len = length($val);

        pcap_queue_u16($id); # option num
        pcap_queue_u16($len);
        pcap_queue_bytes($val);
        pcap_queue_pad_bytes(pcap_calc_pad_bytes($len));
}

sub pcap_queue_option {
        my $name = shift;
        my $val = shift;

        if ($name eq "opt_comment") { pcap_queue_option_varlen(1, $val);
        ##### Section Header Block options
        } elsif ($name eq "shb_hardware") { pcap_queue_option_varlen(2, $val)
        } elsif ($name eq "shb_os") { pcap_queue_option_varlen(3, $val);
        } elsif ($name eq "shb_userappl") { pcap_queue_option_varlen(4, $val);

        } elsif ($name eq "if_name") { pcap_queue_option_varlen(2, $val);
        } elsif ($name eq "if_tsresol") {
                pcap_queue_u16(9); # option #
                pcap_queue_u16(1); # length
                pcap_queue_u8($val);
                pcap_queue_pad_bytes(3);
        } elsif ($name eq "if_filter") { pcap_queue_option_varlen(11, $val);
        } elsif ($name eq "if_os") { pcap_queue_option_varlen(12, $val);

        }
}
sub pcap_output_SHB {
	pcap_print_magic();

	pcap_queue_byte_order_magic();
	pcap_queue_version(1, 0);
	pcap_queue_u64(0xffffffffffffffff); # section length - use -1 for 'figure it out'
	# block total length (32 bits) -- same as above

	# OS option
	pcap_queue_option('opt_comment', "strace-to-pcap");
	#queue_option("opt_comment", "Generated from input file Standard input.");
	#queue_option("shb_userappl", "Text2pcap (Wireshark) 3.4.7 (Git commit e42cbf6a415f)");

	#queue_option(3, "Linux 3.10.0-1160.11.1.el7.x86_64");
	#queue_option(4, "Dumpcap 1.10.14 (Git Rev Unknown from unknown)");
	pcap_queue_end_of_options();
	pcap_output_queued();


	#########################################


	# block type (32 bits)
	# block total length (32 bits)
	# linktype (16 bits)
	# reserved (16 bits) -- must be 0
	# snaplen (32 bits) -- 0 means no limit

	# build an idb
	pcap_print_u32(1); # block type IDB
	# queue_u16(1); # linktype - ethernet - https://www.ietf.org/id/draft-tuexen-opsawg-pcapng-03.html#LINKTYPES
	# queue_u16(101); # linktype - DLT_RAW raw ip - https://www.ietf.org/id/draft-tuexen-opsawg-pcapng-03.html#LINKTYPES
	pcap_queue_u16($pcap_config{'linktype'});
	pcap_queue_u16(0); # reserved - must be 0
	pcap_queue_u32(256*1024); # snaplen - 0 = no limit

	pcap_queue_option("if_name", "strace");

	# tsresol
	pcap_queue_option("if_tsresol", 6);

	#queue_option(11, "\0tcp port 2049 or udp port 514"); # prefixed by an octet designating the type of filter
	#queue_option(12, "Linux 3.10.0-1160.11.1.el7.x86_64");

	pcap_queue_end_of_options();
	pcap_output_queued();
}
sub htons { return (($_[0] >> 8) & 0xff) + (($_[0] << 8) & 0xff00); }
sub ntohs { return htons($_[0]); }
sub u16_endian { (($_[0] >> 8) & 0xff) + (($_[0] & 0xff) << 8); }
sub u32_endian {
        (($_[0] >> 24) & 0x000000ff) + (($_[0] >> 8) & 0x0000ff00) +
        (($_[0] << 8) & 0x00ff0000) + (($_[0] <<24) & 0xff000000); }
sub endian_u16 { u16_endian($_[0]); }
sub endian_u32 { u32_endian($_[0]); }
sub pcap_ip_chksum_add {
        my $ip_chksum = shift;
        my $add = shift;

        $ip_chksum += $add;

        $ip_chksum = (($ip_chksum & 0xffff) + (($ip_chksum >> 16) & 0xffff)) & 0xffff;
        return $ip_chksum;
}
sub pcap_ip_chksum_get { $_[0] ^ 0xffff; }
my $pcap_udp_chksum;
sub pcap_udp_chksum_init { $pcap_udp_chksum = 0; }
sub pcap_udp_chksum_add {
        $pcap_udp_chksum += $_[0];
        $pcap_udp_chksum = (($pcap_udp_chksum & 0xffff) + (($pcap_udp_chksum >> 16) & 0xffff)) & 0xffff;
}
sub pcap_udp_chksum_get { $pcap_udp_chksum ^ 0xffff; }

sub pcap_construct_EPB_opts {
	my $epb_opts = '';
# add epb options
	$epb_opts .= bytes_u16(0x0002); # epb_flags
	$epb_opts .= bytes_u8(0x04); # length of epb_flags
	# bits 16-31 - LL depenent errors
	# bits 9-15 - reserved - must be 0
	# bits 5-8 - fcs length, in octets (0000 if not available)
	# bits 2-4 - reception type
	#     000 - not specified
	#     001 - unicast
	#     010 - multicast
	#     011 - broadcast
	#     100 - promisc
	$epb_opts .= bytes_u16(0x0002); # multicast
	$epb_opts .= bytes_u8(0); # pad to 32-bit
	$epb_opts .= bytes_u8(0); # pad to 32-bit
	$epb_opts .= bytes_u8(0); # pad to 32-bit
	return $epb_opts;
}
sub pcap_construct_EPB {
	my $ts = shift;
	my $ts_subsec = shift;
	my $payload = shift;
	my $payload_len = length($payload);


	my $payload_pad_len = pcap_calc_pad_bytes($payload_len);

	my $EPB_opts = pcap_construct_EPB_opts();
	my $EPB_opts_len = length($EPB_opts);

	my $EPB_len = EPB_HEADER_LEN + $payload_len +
		$payload_pad_len + $EPB_opts_len;

	my $ret = '';

	$ret .= bytes_u32(endian_u32(EPB));

	$ret .= bytes_u32(endian_u32($EPB_len));

	$ret .= bytes_u32(0); # interface id

	# frame
	$ts *= (10**$pcap_config{'subsec_digits'});
	$ts += $ts_subsec;

	my $ts_high = $ts >> 32;
	my $ts_low = $ts & 0xffffffff;

	$ret .= bytes_u32(endian_u32($ts_high));
	$ret .= bytes_u32(endian_u32($ts_low));

	$ret .= bytes_u32(endian_u32($payload_len)); # captured len         # 4 bytes
	$ret .= bytes_u32(endian_u32($payload_len)); # frame length         # 4 bytes

	$ret .= $payload;
	while (length($ret) % 4) { $ret .= chr(0); } # pad to 32-bit

	$ret .= $EPB_opts;
	$ret .= bytes_u32(0); # end of options

	$ret .= bytes_u32(endian_u32($EPB_len));
	return $ret;
}
sub pcap_construct_eth { # irrelevant if frames are not encapsulated in eth
	my $type = shift;
	my $ret = '';

	$ret .= chr(0x0a) . chr(0x02) . chr(0x02) . chr(0x02) . chr(0x02) . chr(0x01); # dst eth
	$ret .= chr(0x0a) . chr(0x02) . chr(0x02) . chr(0x02) . chr(0x02) . chr(0x02); # src eth
	$ret .= chr(($type >> 8) & 0xff) . chr($type & 0xff);
	return $ret;
}
sub construct_ipv4_header {
        my $src_ip = shift;
        my $dst_ip = shift;
        my $len = shift;

        my $ip_chksum = 0;
        my $ret = "";

        my $ip_len = IP_HEADER_LEN + $len;


	# ip version (4 bits)
	# ip header len (4 bits): 20 bytes
	$ret .= chr(0x45); # 0x40 (ipv4) | header: 20 bytes/4 (4-byte words)
	$ret .= chr(0); # ecn
	$ip_chksum = pcap_ip_chksum_add($ip_chksum, 0x4500);

	#total length
	$ret .= chr(($ip_len >> 8) & 0xff) . chr($ip_len & 0xff);
	$ip_chksum = pcap_ip_chksum_add($ip_chksum, $ip_len);

	# id
	$ret .= chr(0x12) . chr(0x34); # id: 0x1234
	$ip_chksum = pcap_ip_chksum_add($ip_chksum, 0x1234);

	$ret .= chr(0) . chr(0); # 3 bits of flags + 13 bits of fragment offset
	$ip_chksum = pcap_ip_chksum_add($ip_chksum, 0);

	$ret .= chr(255); # ttl = 255
	$ret .= chr(17); # UDP
	$ip_chksum = pcap_ip_chksum_add($ip_chksum, 0xff11);

	# calc checksum of the rest, then output checksum, then remaining bytes
	$ip_chksum = pcap_ip_chksum_add($ip_chksum, ($src_ip >> 16) & 0xffff);
	$ip_chksum = pcap_ip_chksum_add($ip_chksum, $src_ip & 0xffff);
	$ip_chksum = pcap_ip_chksum_add($ip_chksum, ($dst_ip >> 16) & 0xffff);
	$ip_chksum = pcap_ip_chksum_add($ip_chksum, $dst_ip & 0xffff);

	$ip_chksum = pcap_ip_chksum_get($ip_chksum);
	$ret .= chr(($ip_chksum >> 8) & 0xff) . chr($ip_chksum & 0xff);

	$ret .= chr(($src_ip >> 24) & 0xff) . chr(($src_ip >> 16) & 0xff) .
		chr(($src_ip >> 8) & 0xff) . chr($src_ip & 0xff);
	$ret .= chr(($dst_ip >> 24) & 0xff) . chr(($dst_ip >> 16) & 0xff) .
		chr(($dst_ip >> 8) & 0xff) . chr($dst_ip & 0xff);

	return $ret;
}
sub pcap_construct_udp {
        my $src_ip = shift;
        my $dst_ip = shift;
        my $src_port = shift;
        my $dst_port = shift;
        my $data = shift;
        my $ret = "";

        my $len = length($data);
        my $udp_len = $len + UDP_HEADER_LEN;

        $ret .= chr(($src_port >> 8) & 0xff) . chr($src_port & 0xff);
        $ret .= chr(($dst_port >> 8) & 0xff) . chr($dst_port & 0xff);
        $ret .= chr(($udp_len >> 8) & 0xff) . chr($udp_len & 0xff);

        $ret .= chr(0) . chr(0); # checksum

        for (my $i = 0 ; $i < $len ; $i++) {
                $ret .= chr(ord(substr($data, $i, 1)));
        }
        return $ret;
}
sub pcap_output_udp {
	my $src_ip = shift;
	my $dst_ip = shift;
	my $src_port = shift;
	my $dst_port = shift;
	my $data = shift;

	my $len = length($data);
	my $pad_bytes = pcap_calc_pad_bytes($len);

        pcap_print_u16(u16_endian($src_port));       # 2 bytes
        pcap_print_u16(u16_endian($dst_port));       # 2 bytes

	$data .= sprintf("%c", 0) if ($len % 2);

	pcap_print_u16(u16_endian($len + 8));        # 2 bytes
	pcap_print_u16(0);                           # 2 bytes - checksum - fudge with '0'

	for (my $i = 0 ; $i < $len ; $i++) { pcap_print_u8(ord(substr($data, $i, 1))); }
	pcap_print_pad_bytes($len % 4);
}
sub output_udp_syslog_frame {
	my $ts = shift;
	my $ts_subsec = shift;
	my $call_completion = shift;
	my $payload = shift;

	my $dst_ip = ($call_completion == CALL) ? $pcap_config{'dst_ip_call'} : $pcap_config{'dst_ip_completion'};

	$payload = construct_udp($pcap_config{'src_ip'}, $dst_ip, 30000, 514, $payload);
	$payload = construct_ipv4_header($pcap_config{'src_ip'}, $dst_ip, length($payload)) . $payload;

	if ($pcap_config{'linktype'} eq LINKTYPE_ETH) {
		$payload = construct_eth(0x0800) . $payload;
	} elsif ($config{'linktype'} eq LINKTYPE_DLT_RAW) {
		# nothing to do
	}

	my $EPB_data = construct_EPB($ts, $ts_subsec, $payload);

	printf "%s", $EPB_data;
}

















if (! -t STDIN) {
	$config{'input_pipe'} = true;
	$config{'in_fh'} = \*STDIN;
} elsif (defined $ARGV[0]) {
	$config{'input_file'} = $ARGV[0];

	if ($config{'progress'}) {
		my @st = stat $config{'input_file'} or die "Unable to find input file $!\n";
		$progress_state{'file_size'} = $st[7];
	}

	open $config{'in_fh'}, '<', $config{'input_file'} or die "failed to open input file: $!\n";
} else {
	print "no file specified, and not reading from a pipe\n";
	usage();
        exit();
}

while (my $line = readline($config{'in_fh'})) {
	my ($dfd, $dfd_path, $other_args);
	my ($old_pid_string, $old_timestamp_string, $old_delay_string, $old_elapsed_string);
#	my ($old_delay_string);
	my %trace_entry = (
		'pid' => '',
		'delay' => '',
		'timestamp' => '',
		'syscall' => '',
		'args' => '',
		'ret' => '',
		'elapsed' => '',

		'execname' => '',
		'this_line_execname' => '',
		'dfd' => '',
		'dfd_path' => '',
		'msg' => '',
	);

	chomp $line;
	$trace_entry{'line'} = $line;
	my @matches;

	if ($trace_entry{'line'} eq "" or substr($trace_entry{'line'}, 0, 1) eq "#") { next; }

	if ($config{'normalize_pids'}) {
		# normalize the alternate pid string: '[pid #####]'
		if ( (my $raw_pid_str, $trace_entry{'pid'}, my $line_remainder) = $trace_entry{'line'} =~ $regexes{'extract_alt_pid'}) {
			printf("normalizing pid string: '%s' => %d (remainder *%s*)\n", $raw_pid_str, $trace_entry{'pid'}, $line_remainder) if ($config{'debug'} >= 1);
			$trace_entry{'line'} = "" . $trace_entry{'pid'} . " " . $line_remainder;
		}
	}

	if (($trace_entry{'pid'}, $trace_entry{'timestamp'}, $trace_entry{'delay'}, $trace_entry{'syscall'}) = $trace_entry{'line'} =~ $regexes{'resuming_unfinished'}) {
		my $save_line = retrieve_unfinished($trace_entry{'pid'});

if (!defined($trace_entry{'syscall'})) {
	printf("op is not defined with line: %s\n", $trace_entry{'line'});
}
#		$trace_entry{'delay'} = trim($trace_entry{'delay'}) if defined($trace_entry{'delay'});
		$save_line = sprintf("%s %s%s%s(UNKNOWN",
			$trace_entry{'pid'}, defined($trace_entry{'timestamp'}) ? $trace_entry{'timestamp'} . " " : "",
			defined($trace_entry{'delay'}) ? $trace_entry{'delay'}  : "",
			$trace_entry{'syscall'}) if ($save_line eq "");

		store_unfinished($trace_entry{'pid'}, $save_line);
		next;
	} elsif (($trace_entry{'pid'}, $trace_entry{'timestamp'}, $trace_entry{'delay'}, $trace_entry{'syscall'}, $trace_entry{'op_args'}) = $trace_entry{'line'} =~ $regexes{'unfinished'}) {

		$trace_entry{'timestamp'} = trim($trace_entry{'timestamp'}) if (defined($trace_entry{'timestamp'})); # FIXME: fix an extra space a the end of this

		my $save_line = retrieve_unfinished($trace_entry{'pid'});
		if (!defined($trace_entry{'delay'}) && defined($trace_entry{'timestamp'}) && $trace_entry{'timestamp'} ne '') {
			my $last_sysret = get_last_sysret($trace_entry{'pid'});

		$trace_entry{'delay'} = trim($trace_entry{'delay'}) if defined($trace_entry{'delay'});
			$trace_entry{'delay'} = format_delay(($last_sysret eq "") ? 0 : ts_to_sec($trace_entry{'timestamp'}) - $last_sysret);
		}

		if ($config{'debug'} >= 2) {
			printf("syscall unfinished: %s\n", $trace_entry{'line'});

			printf("pid: %s\n", get_match_val($trace_entry{'pid'}));
			printf("timestamp: %s\n", get_match_val($trace_entry{'timestamp'}));
			printf("relative_time: %s\n", get_match_val($trace_entry{'delay'}));
			printf("op: %s\n", $trace_entry{'syscall'});
			printf("op args: %s\n", get_match_val($trace_entry{'op_args'}));
		}

		$save_line = sprintf("%s %s%s%s(%s",
			$trace_entry{'pid'},
			$trace_entry{'timestamp'} ne '' ? $trace_entry{'timestamp'} . ' ' : '',
			$trace_entry{'delay'} ne '' ? $trace_entry{'delay'} . ' ' : '',
			$trace_entry{'syscall'}, defined($trace_entry{'op_args'}) ? $trace_entry{'op_args'} : "");

		store_unfinished($trace_entry{'pid'}, $save_line);
		next;
	} elsif (($trace_entry{'pid'}, my $resumed_ts, $trace_entry{'delay'}, $trace_entry{'syscall'}, my $remainder) = $trace_entry{'line'} =~ $regexes{'resumed'}) {
		my $last_sysret = get_last_sysret($trace_entry{'pid'});

		if ($config{'debug'} >= 2) {
			printf("resumed syscall line: %s\n", $trace_entry{'line'});

			printf("pid: %d\n", $trace_entry{'pid'});
			printf "delay: %.6f\n", $trace_entry{'delay'} if defined($trace_entry{'delay'});
			printf("timestamp: %s\n", get_match_val($trace_entry{'timestamp'}));
			printf("op: %s\n", $trace_entry{'syscall'});
			printf("remainder of line: %s\n", get_match_val($remainder));
		}
		my $stored_line = retrieve_unfinished($trace_entry{'pid'});
#printf "retrieved line: %s\n", $stored_line;

		if ($stored_line eq "") {
			printf("couldn't find an unfinished line for pid %d to match: %s\n", $trace_entry{'pid'}, $trace_entry{'line'}) if ($config{'debug'} >= 2);
		} else {
			$trace_entry{'line'} = $stored_line . trim($remainder);
			printf("attached stored line '%s', resulting in completed line '%s'\n",
				$stored_line, $trace_entry{'line'}) if ($config{'debug'} >= 2);
		}

#printf "rebuilt line: %s - last_sysret: %.6f\n", $trace_entry{'line'}, $last_sysret;

	} # end of 'resumed'

	$trace_entry{'orig_line'} = $trace_entry{'line'};
#	$trace_entry{'line'} = $trace_entry{'line'};

	# separate off execname, in case we're reprocessing one of our own
	if (($trace_entry{'pid'}, $trace_entry{'this_line_execname'}, $trace_entry{'timestamp'}, my $rest) = $trace_entry{'line'} =~ $regexes{'line_with_execname'}) {
		if ($config{'debug'} >= 1) {
			printf("looks like the line already has an execname: %s\n", $trace_entry{'this_line_execname'});
			printf("  pid: %d\n", $trace_entry{'pid'});
			printf("  timestamp: %s\n", defined($trace_entry{'timestamp'}) ? $trace_entry{'timestamp'} : "<undefined>");
			printf("  the rest: %s\n", $rest);

		}
		set_execname($trace_entry{'pid'}, $trace_entry{'this_line_execname'}) if (get_execname($trace_entry{'pid'}) eq "");
		$trace_entry{'line'} = sprintf("%s%s%s",
			defined($trace_entry{'pid'}) ? $trace_entry{'pid'} . " " : "",
			defined($trace_entry{'timestamp'}) ? $trace_entry{'timestamp'} . " " : "",
			$rest);
	} else { $trace_entry{'this_line_execname'} = ""; }

	extract_metadata(\%trace_entry); # extract necessary metadata from the line

	next if ($config{'times'});

	if (($trace_entry{'syscall'}, $trace_entry{'args'}, $trace_entry{'ret'}) = $trace_entry{'line'} =~ $regexes{'new_syscall'}) {

#		$trace_entry{'pid'} = trim($trace_entry{'pid'}) if defined($trace_entry{'pid'});
#		$trace_entry{'timestamp'} = trim($trace_entry{'timestamp'}) if defined($trace_entry{'timestamp'});
#		$trace_entry{'delay'} = trim($trace_entry{'delay'}) if (defined($trace_entry{'delay'}));;
#printf "delay %s\n", $trace_entry{'delay'} if defined $trace_entry{'delay'};

#		my $foo_args = $trace_entry{'args'};
#		$trace_entry{'args'} = trim($trace_entry{'args'});
#		printf "args trimmed from '%s' to '%s'\n", $foo_args, $trace_entry{'args'} if ($foo_args ne $trace_entry{'args'});

		if ((!defined($trace_entry{'delay'}) || $trace_entry{'delay'} eq '') && defined($trace_entry{'timestamp'})) {
			my $last_sysret = get_last_sysret($trace_entry{'pid'});
			if ($last_sysret eq "") {
				$trace_entry{'delay'} = 0;
			} else {
				$trace_entry{'delay'} = ts_to_sec($trace_entry{'timestamp'}) - $last_sysret;
				printf("computed delay '%.6f' from timestamp '%s' (%.6f seconds) and last_sysret '%.6f'\n",
					$trace_entry{'delay'}, $trace_entry{'timestamp'}, ts_to_sec($trace_entry{'timestamp'}), $last_sysret) if ($config{'debug'} >= 2);
			}
		}
		if (defined($trace_entry{'timestamp'}) && defined($trace_entry{'elapsed'})) {
			my $sysret = ts_to_sec($trace_entry{'timestamp'}) + $trace_entry{'elapsed'};
			set_last_sysret($trace_entry{'pid'}, $sysret);
		}

		if ($config{'debug'} >= 1) {
			printf("%12s - %s\n", "pid", get_match_val($trace_entry{'pid'}));
			printf("%12s - %s\n", "timestamp", get_match_val($trace_entry{'timestamp'}));
			printf("%12s - %s\n", "relative_ts", get_match_val($trace_entry{'delay'}));
			printf("%12s - %s\n", "op", get_match_val($trace_entry{'syscall'}));
			printf("%12s - %s\n", "args", get_match_val($trace_entry{'args'}));
			printf("%12s - %s\n", "ret", get_match_val($trace_entry{'ret'}));
			printf("%12s - %s\n", "elapsed", get_match_val($trace_entry{'elapsed'}));
		}

		if (parse_syscall(\%trace_entry)) {

		} elsif (is_generic_fd_function($trace_entry{'syscall'})) {
			parse_generic_fd_function(\%trace_entry);
		} elsif (is_generic_dfd_path_function($trace_entry{'syscall'})) {
			parse_generic_dfd_path_function(\%trace_entry);
		} elsif (do_not_parse_function($trace_entry{'syscall'})) {
			printf "%s is a do-not-parse\n", $trace_entry{'syscall'} if ($config{'debug'} >= 1);
		} else {
#			log_error(sprintf("matched the main pattern, but didn't find a matching syscall for '%s'\n\tfull string: %s\n", $trace_entry{'syscall'}, $trace_entry{'line'}));
			$unknown_syscalls{$trace_entry{'syscall'}} = 1;
		}

		$trace_entry{'this_line_execname'} = get_execname($trace_entry{'pid'}) if (!defined($trace_entry{'this_line_execname'}) || $trace_entry{'this_line_execname'} eq "");

	} elsif (($old_pid_string, $old_timestamp_string, $old_delay_string, $trace_entry{'msg'}, my $return_code) = $trace_entry{'line'} =~ $regexes{'process_exited'}) {
		$trace_entry{'syscall'} = '';
		if (defined($trace_entry{'pid'})) {
			$trace_entry{'this_line_execname'} = get_execname($trace_entry{'pid'}) if ($trace_entry{'this_line_execname'} eq "");
		}
	} elsif (($old_pid_string, $old_timestamp_string, $old_delay_string, my $signal, my $siginfo) = $trace_entry{'line'} =~ $regexes{'process_signal'}) {
		$trace_entry{'syscall'} = '';
		$trace_entry{'this_line_execname'} = get_execname($trace_entry{'pid'}) if (defined($trace_entry{'pid'}) && $trace_entry{'this_line_execname'} eq "");
#		if (defined($trace_entry{'pid'})) {
#			$trace_entry{'this_line_execname'} = get_execname($trace_entry{'pid'}) if ($trace_entry{'this_line_execname'} eq "");
#			$trace_entry{'line'} = sprintf("%d (%s) %s%s --- %s %s ---",
#				$trace_entry{'pid'}, $trace_entry{'this_line_execname'},
#				(defined($trace_entry{'timestamp'}) ? $trace_entry{'timestamp'} . " " : ""),
#				format_delay($trace_entry{'delay'}),
#				$signal, $siginfo);
#		}
		$trace_entry{'msg'} = sprintf("--- %s %s ---", $signal, $siginfo);
	} elsif ((my $kill_sig) = $trace_entry{'line'} =~ $regexes{'killed'}) {
		# nothing to do, really
		$trace_entry{'syscall'} = '';
		$trace_entry{'this_line_execname'} = get_execname($trace_entry{'pid'}) if (defined($trace_entry{'pid'}) && $trace_entry{'this_line_execname'} eq "");
		$trace_entry{'msg'} = sprintf("+++ killed by %s +++", $kill_sig);

	} elsif (($old_pid_string, $old_timestamp_string, $old_delay_string, my $partial_line) = $trace_entry{'line'} =~ $regexes{'strace_partial_line'}) {
		log_error(sprintf("line is a partial strace line, perhaps the trace was truncated: %s\n", $trace_entry{'line'}));
		if (defined($trace_entry{'pid'})) {
			$trace_entry{'this_line_execname'} = get_execname($trace_entry{'pid'}) if ($trace_entry{'this_line_execname'} eq "");
			$trace_entry{'line'} = sprintf("%d (%s) %s%s%s",
				$trace_entry{'pid'}, $trace_entry{'this_line_execname'},
				(defined($trace_entry{'timestamp'}) ? $trace_entry{'timestamp'} . " " : ""),
				format_delay($trace_entry{'delay'}),
				$partial_line);
		}
	} else {
		log_error(sprintf("didn't match any patterns: %s\n", $trace_entry{'line'}));
	}

	if ($config{'output_lines'}) {
		$trace_entry{'line'} = reconstruct_line(\%trace_entry);
	}
	if ($config{'output_pcap'}) {
		

	}

	add_syscall_stats(\%trace_entry);

	if ($config{'output_lines'}) {
		if ($config{'debug'} >= 1) {
			printf("<<<=== %s\n", $trace_entry{'orig_line'});
			printf("===>>> %s\n", $trace_entry{'line'});
		} else {
			output_trace_entry(\%trace_entry);
		}
	} elsif ($config{'progress'}) {
		my $pos = tell($config{'in_fh'});
		if ($progress_state{'file_size'}) {
			my $this_pct = int($pos / $progress_state{'file_size'} * 100.0 * 100.0); # get in 0.01% intervals
			if ($this_pct != $progress_state{'last_progress_printed'}) {
				printf "completed: %d/%d - %.02f%%\r", $pos, $progress_state{'file_size'}, $this_pct / 100.0;
				$progress_state{'last_progress_printed'} = $this_pct;
			}
		} else {
			printf "completed: %d bytes\n", $pos;
		}
	}
}
flush_trace_entries();

if ($config{'times'}) {
	printf "start time: %s\n", $tracking_data{'trace_stats'}{'start_time'};
	printf "end time: %s\n", $tracking_data{'trace_stats'}{'end_time'};
	my $sts = timestamp_to_seconds($tracking_data{'trace_stats'}{'start_time'});
	my $ets = timestamp_to_seconds($tracking_data{'trace_stats'}{'end_time'});

	printf "elapsed time: %f\n", $ets - $sts;
}

compute_overall_stats();
output_overall_stats() if ($config{'combined_stats'});
output_per_pid_stats() if ($config{'proc_stats'});
display_pidtree() if $config{'pidtree'};

output_errors();

#print Dumper(\%tracking_data);
