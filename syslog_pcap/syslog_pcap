#!/usr/bin/perl -w

use warnings;
use strict;

no warnings 'portable';

STDOUT->autoflush(1);

my $program_name = 'syslog-pcap'; # for lack of a better name
my $program_version = '0.1'; # version number of this thing


use constant {
	false => 0,
	true => 1,

	EPB_HEADER_LEN => 9*4, # 9*4 + any options size
	ETH_HEADER_LEN => 14, # 2x eth addrs + 4-byte type
	IP_HEADER_LEN => 20,
	UDP_HEADER_LEN => 8,

	# linktypes
	LINKTYPE_ETH => 1, # https://www.ietf.org/id/draft-tuexen-opsawg-pcapng-03.html#LINKTYPES
	LINKTYPE_DLT_RAW => 101, # https://www.ietf.org/id/draft-tuexen-opsawg-pcapng-03.html#LINKTYPES
my $queued_bytes = '';
my $queued_len = 0;

	BYTE_ORDER_MAGIC => 0x1a2b3c4d,
my $DEBUG = 0;

sub trim {
	my $s = shift;
	$s =~ s/^\s+|\s+$//g;
	return $s
}

	SHB => 0x0a0d0d0a,
	IDB => 0x00000001,
#	PB => 0x00000002, # obsolete
	SPB => 0x00000003,
	NRB => 0x00000004,
	ISB => 0x00000005,
	EPB => 0x00000006,
#	SDJ => 0x00000009,
#	DSB => 0x0000000a, # also 'ZigBee NWK Key Data', 'ZigBee APS Key Data'
	CB => 0x00000bad,
	CB2 => 0x40000bad,



	# option-related
	EPB_FLAG_DIRECTION_UNKNOWN => 0,
	EPB_FLAG_INBOUND => 0x0001,
	EPB_FLAG_OUTBOUND => 0x0002,

	EPB_FLAG_RECEPTION_TYPE_UNKNOWN => 0,
	EPB_FLAG_UNICAST => (1 << 2),
	EPB_FLAG_MULTICAST => (2 << 2),
	EPB_FLAG_BROADCAST => (3 << 2),
	EPB_FLAG_PROMISC => (4 << 2),

	END_OF_OPTIONS => 0,

        IPPROTO_TCP => 6,
        IPPROTO_UDP => 17,
};
my %patterns;
my %regexes;

# (?=pattern)	is a positive look-ahead assertion
# (?!pattern)	is a negative look-ahead assertion
# (?<=pattern)	is a positive look-behind assertion
# (?<!pattern)	is a negative look-behind assertion

$patterns{'ip_octet'} = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))";
$patterns{'ipv4_addr'} = "(?:(?:$patterns{'ip_octet'}\.){3}(?:$patterns{'ip_octet'}))";

# iso_8601 - 2006-08-14T02:34:56(.[0-9]+)?-06:00 - YYYY-MM-DD<T>HH:MM:SS,<microseconds><-+><timezone offset from UTC>
# iso_3339 - 2006-08-14 02:34:56(.[0-9]+)?-06:00
# rfc_email - Mon, 14 Aug 2006 02:34:56 -0600

%patterns = (%patterns,
	'epoch_seconds' => '(?:[1-9][0-9]{8,9})',
	'seconds' => '(?:0|[1-9][0-9]{0,7})',
	'subseconds' => '(?:(?<![0-9])(?:[0-9]{3}){1,3})', # ms, us, ns -- multiple of 3 digits

	'Y' => '(?:19[7-9][0-9]|[2-9][0-9])',

	# month of year - %m - 00..12
	'datefmt feb m' => '(?:02)',
	'datefmt 30_day m' => '(?:0[469]|11)',
	'datefmt 31_day m' => '(?:(?:0[134578])|(?:1[02]))',
);
%patterns = (%patterns,
	# day of month - %d
	'datefmt feb d' => '(?:0[1-9]|[12][0-9])', # 29-day months - day of month - %d - 00..29
	'datefmt 30_day d' => '(?:0[1-9]|[12][0-9]|30)', # 30-day months - day of month - %d - 00..30
	'datefmt 31_day d' => '(?:0[1-9]|[12][0-9]|3[01])', # 31-day months - day of month - %d - 00..31

	# short month name - 'Jan', etc.
	#
	'datefmt feb b' => '(?:Feb)',
	'datefmt 30_day b' => '(?:Apr|Jun|Sep|Nov)',
	'datefmt 31_day b' => '(?:Jan|Mar|May|Jul|Aug|Oct|Dec)',

	'H' => '(?:(?:[01][0-9]|2[0-3]))',
	'M' => '(?:[0-5]:[0-9])',
	'S' => '(?:[0-5][0-9]|60)',
	'H:M:S_leapsecond' => '(?:23:59:60)',

	'DOW' => '(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)'
);
$patterns{'datefmt feb m-d'} = "(?:$patterns{'datefmt feb m'}-$patterns{'datefmt feb d'})";
$patterns{'datefmt 30_day m-d'} = "(?:$patterns{'datefmt 30_day m'}-$patterns{'datefmt 30_day d'})";
$patterns{'datefmt 31_day m-d'} = "(?:$patterns{'datefmt 31_day m'}-$patterns{'datefmt 31_day d'})";

$patterns{'Y-m-d'} = "(?:$patterns{'Y'}-(?:$patterns{'datefmt feb m-d'}|$patterns{'datefmt 30_day m-d'}|$patterns{'datefmt 31_day m-d'}))";


#$patterns{'Ymd'} = "(?:$patterns{'Y'}-(?:$patterns{'feb'}|$patterns{'30_day_md'}|$patterns{'31_day_md'}))";
$patterns{'H:M:S'} = "(?:$patterns{'H'}:$patterns{'M'}:$patterns{'S'}|$patterns{'H:M:S_leapsecond'})";
$patterns{'ts_offset'} = "(?:[-+]$patterns{'H'}:$patterns{'M'})";

$patterns{'datefmt feb d b'} = "(?:$patterns{'datefmt feb d'} $patterns{'datefmt feb b'})";
$patterns{'datefmt 30_day d b'} = "(?:$patterns{'datefmt 30_day d'} $patterns{'datefmt 30_day b'})";
$patterns{'datefmt 31_day d b'} = "(?:$patterns{'datefmt 31_day d'} $patterns{'datefmt 31_day b'})";

$patterns{'datefmt d b'} = "(?:$patterns{'datefmt feb d b'}|$patterns{'datefmt 30_day d b'}|$patterns{'datefmt 31_day d b'}";

#   IDB - interface description block
#   EPB - enhanced packet block
#   SPB - simple packet block
#   NRB - name resolution block
#   ISB - interface statistics block
#   CB - custom block
#      - systemd Journal Export Block
#   DSB - Decryption Secrets Block
$patterns{'feb_md'} = '(?:02-(?:0[1-9]|[12][0-9]))';
$patterns{'iso_8601_timestamp'} = "(?:($patterns{'Y-m-d'})T($patterns{'H:M:S'})[,.]($patterns{'subseconds'})($patterns{'ts_offset'}))";
$patterns{'iso_3339_timestamp'} = "(?:($patterns{'Y-m-d'}) ($patterns{'H:M:S'})[,.]($patterns{'subseconds'})($patterns{'ts_offset'}))";
$patterns{'epoch_timestamp'} = "(?:($patterns{'epoch_seconds'})\.($patterns{'subseconds'}))";
$patterns{'seconds_time'} = "(?:($patterns{'seconds'}?)(?:\.($patterns{'subseconds'}))?)";

%regexes = (%regexes,
	'Y-m-d' => qr/$patterns{'Y-m-d'}/,
);
$regexes{'iso_8601_line'} = qr/^$patterns{'iso_8601_timestamp'}\s(.+)$/;
$regexes{'iso_3339_line'} = qr/^$patterns{'iso_3339_timestamp'}\s+(.+)$/;
$regexes{'epoch_line'} = qr/^$patterns{'epoch_timestamp'}\s+(.+)$/;
$regexes{'seconds_time'} = qr/^$patterns{'seconds_time'}$/;
$regexes{'adjustment_time'} = qr/^(?:($patterns{'seconds'}?)(?:\.([0-9]+)?))$/;

my %config = (
	'debug' => 0,
	'tag' => '',
	'max_queue' => 20,

	'subsec_digits' => 6,
	'linktype' => LINKTYPE_DLT_RAW,

	'ip_id' => 0x1234,
	'ip_ttl' => 255,
	'src_ip' => 0x7f000001,
	'dst_ip' => 0x7f000001,
	'src_port' => 30000,
	'dst_port' => 514,
);

	'ts_adjust' => 0,
	'ts_subsec_adjust' => 0,

sub print_pad_bytes {
	my $len = shift;
	for (my $i = 0 ; $i < $len ; $i++) {
		printf("%c", 0);
	}
}
sub bytes_u8 { return (chr($_[0] & 0xff)); }
sub bytes_u16 { return (chr(($_[0] >> 8) & 0xff) . chr($_[0] & 0xff)); }
sub bytes_u32 { return (chr(($_[0] >> 24) & 0xff) . chr(($_[0] >> 16) & 0xff) .
	chr(($_[0] >> 8) & 0xff) . chr($_[0] & 0xff)); }
sub bytes_u64 { bytes_u32($_[0] >> 32) . bytes_u32($_[0] & 0xffffffff); }

sub print_u8 {
	my $val = shift;

	printf("%c", $val & 0xff);
}
sub print_u16 {
	my $val = shift;

	printf("%c%c", $val & 0xff, ($val >> 8) & 0xff);
}
sub print_u32 {
	my $val = shift;

	printf("%c%c%c%c",
		$val & 0xff, ($val >> 8) & 0xff,
		($val >> 16) & 0xff, ($val >> 24) & 0xff);
}
GetOptions(
        'debug|verbose|v+' => \$config{'debug'},
	'tag=s' => \$config{'tag'},
	'adjust_ts=s' => sub {
		shift;
		my $adjustment = shift;
		printf STDERR "adjustment of %s seconds\n", $adjustment;
		if (my ($adjust_s, $adjust_subsec) = $adjustment =~ $regexes{'adjustment_time'}) {
			$config{'ts_adjust'} = $adjust_s if (defined($adjust_s));
			if (defined($adjust_subsec)) {
				$adjust_subsec *= 10**($config{'subsec_digits'} - length($adjust_subsec));
				$config{'ts_subsec_adjust'} = $adjust_subsec;
			}
		} else {
			printf STDERR "adjustment %s didn't match\n", $adjustment;
		}
	},
);

sub output_queued {
	printf STDERR "queued len: %d (%x) - writing %d (%x), count of queued bytes: %d (%x)\n",
	$queued_len, $queued_len,
	$queued_len + 12, $queued_len + 12,
	length($queued_bytes), length($queued_bytes) if ($DEBUG >= 1);

	print_u32($queued_len + 12);
	for (my $i = 0 ; $i < $queued_len ; $i++) {
		printf("%c", ord(substr($queued_bytes, $i, 1)) & 0xff);
	}
	print_pad_bytes(calc_pad_bytes($queued_len));
	print_u32($queued_len + 12);
	$queued_bytes = '';
	$queued_len = 0;
}

sub queue_u8 {
	$queued_bytes .= chr(int($_[0]) & 0xff);
	$queued_len++;
	printf STDERR "queued 1 byte\n" if ($DEBUG >= 1);
}
sub queue_u16 {
	my $val = shift;

	$queued_bytes .= sprintf("%c%c", $val & 0xff, ($val >> 8) & 0xff);
	$queued_len += 2;
	printf STDERR "queued 2 bytes\n" if ($DEBUG >= 1);
}
sub queue_u32 {
	my $val = shift;

	$queued_bytes .= sprintf("%c%c%c%c",
		$val & 0xff, ($val >> 8) & 0xff,
		($val >> 16) & 0xff, ($val >> 24) & 0xff);
	$queued_len += 4;
	printf STDERR "queued 4 bytes\n" if ($DEBUG >= 1);
}
sub queue_u64 {
	my $val = shift;

my $time_parser = DateTime::Format::Strptime->new( 'pattern' => '%Y-%m-%d %T %z' ); # iso3339 or iso8601 format
	queue_u32($val & 0xffffffff);
	queue_u32(($val >> 32) & 0xffffffff);
	printf STDERR "queued 8 bytes\n" if ($DEBUG > 1);
}
sub queue_bytes {
	my $val = shift;
	my $len = length($val);

	for (my $i = 0 ; $i < $len ; $i++) {
		$queued_bytes .= sprintf("%c", ord(substr($val, $i, 1)) & 0xff);
		$queued_len++;
	}
	printf STDERR "queued %d bytes\n", $len if ($DEBUG >= 1);
}
sub queue_pad_bytes {
	my $len = shift;
	for (my $i = 0 ; $i < $len ; $i++) {
		$queued_bytes .= sprintf("%c", 0);
		$queued_len++;
	}
	printf STDERR "queued %d pad bytes\n", $len if ($DEBUG >= 1);
}
sub queue_end_of_options {
	queue_u16(0); # opt_endofopt = 0
	queue_u16(0); # option length = 0
}

sub calc_pad_bytes { ($_[0] % 4 == 0) ? 0 : 4 - ($_[0] % 4); }
# magic (32 bits)
sub print_magic { print_u32(SHB); }
# byte order magic (32 bits)
# 0x1a2b3c4d by endian
sub queue_byte_order_magic {
	$queued_bytes .= sprintf("%c%c%c%c", 0x4d, 0x3c, 0x2b, 0x1a);
	$queued_len += 4;
}
# major version (16 bits)
# minor version (16 bits)
sub queue_version {
	my $maj = shift;
	my $min = shift;

	queue_u16($maj);
	queue_u16($min);
}



# SECTION (pcapng file) HEADER BLOCK
#
# from https://github.com/pcapng/pcapng/blob/master/reference-draft-tuexen-opsawg-pcapng.xml

#    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 0 |                   Block Type = 0x0A0D0D0A                     |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 4 |                      Block Total Length                       |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 8 |                      Byte-Order Magic                         |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#12 |          Major Version        |         Minor Version         |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#16 |                                                               |
#   |                          Section Length                       |
#   |                                                               |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#24 /                                                               /
#   /                      Options (variable)                       /
#   /                                                               /
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#   |                      Block Total Length                       |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# SHB - mandatory; must appear at least once in each file
# optional blocks:
#   IDB - interface description block
#   EPB - enhanced packet block
#   SPB - simple packet block
#   NRB - name resolution block
#   ISB - interface statistics block
#   CB - custom block
#      - systemd Journal Export Block
#   DSB - Decryption Secrets Block
#

# options
#	opt_endofopt - code: 0; length: 0
#	opt_comment - code: 1; length: variable
#
# section header block options
#	2 - shb_hardware  - variable length
#	3 - shb_os        - variable length
#	4 - shb_userappl  - variable length
#
#
# interface description block
#                        1                   2                   3
#    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 0 |                    Block Type = 0x00000001                    |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 4 |                      Block Total Length                       |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 8 |           LinkType            |           Reserved            |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#12 |                            SnapLen                            |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#16 /                                                               /
#   /                      Options (variable)                       /
#   /                                                               /
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#   |                      Block Total Length                       |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# Interface Description Block options'
#	3 - if_description (variable)
#	4 - if_IPv4addr (8 bytes)
#	5 - if_IPv6addr (17 bytes)
#	6 - if_MACaddr (8 bytes)
#	7 - if_EUIaddr (8 bytes)
#	8 - if_speed (8 bytes)
#	9 - if_tsresol (1 byte)
#	10 - if_tzone (4 bytes)
#	11 - if_filter (variable, minimum 1)
#	12 - if_os (variable)
#	13 - if_fcslen (1 byte)
#	14 - if_tsoffset (8 bytes)
#	15 - if_hardware (variable)
#	16 - if_txspeed (8 bytes)
#	17 - if_rxspeed (8 bytes)

# Enhanced Packet Block
#                        1                   2                   3
#    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 0 |                    Block Type = 0x00000006                    |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 4 |                      Block Total Length                       |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 8 |                         Interface ID                          |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#12 |                        Timestamp (High)                       |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#16 |                        Timestamp (Low)                        |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#20 |                    Captured Packet Length                     |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#24 |                    Original Packet Length                     |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#28 /                                                               /
#   /                          Packet Data                          /
#   /              variable length, padded to 32 bits               /
#   /                                                               /
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#   /                                                               /
#   /                      Options (variable)                       /
#   /                                                               /
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#   |                      Block Total Length                       |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Table 4: Enhanced Packet Block Options
# Name		Code	Length			Multiple allowed?
# epb_flags	2	4			no
# epb_hash	3	variable, minimum hash type-dependent	yes
# epb_dropcount	4	8			no
# epb_packetid	5	8			no
# epb_queue	6	4			no
# epb_verdict	7	variable, minimum verdict type-dependent	yes


# Simple Packet Block
#                        1                   2                   3
#    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 0 |                    Block Type = 0x00000003                    |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 4 |                      Block Total Length                       |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 8 |                    Original Packet Length                     |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#12 /                                                               /
#   /                          Packet Data                          /
#   /              variable length, padded to 32 bits               /
#   /                                                               /
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#   |                      Block Total Length                       |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Name Resolution Block
#                        1                   2                   3
#    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 0 |                    Block Type = 0x00000004                    |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 4 |                      Block Total Length                       |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
# 8 |      Record Type              |      Record Value Length      |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#12 /                       Record Value                            /
#   /              variable length, padded to 32 bits               /
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#   .                                                               .
#   .                  . . . other records . . .                    .
#   .                                                               .
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#   |  Record Type = nrb_record_end |   Record Value Length = 0     |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#   /                                                               /
#   /                      Options (variable)                       /
#   /                                                               /
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#   |                      Block Total Length                       |
#   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

# Name			Code	Length
#nrb_record_end		0x0000	0
#nrb_record_ipv4	0x0001	variable
#nrb_record_ipv6	0x0002	variable

# Table 7: Name Resolution Block Options
# Name	Code	Length	Multiple allowed?
# ns_dnsname	2	variable	no
# ns_dnsIP4addr	3	4	no
# ns_dnsIP6addr	4	16	no

sub queue_option_varlen {
	my $id = shift;
	my $val = shift;
	my $len = length($val);

	queue_u16($id); # option num
	queue_u16($len);
	queue_bytes($val);
	queue_pad_bytes(calc_pad_bytes($len));
}

sub queue_option {
	my $name = shift;
	my $val = shift;

	if ($name eq "opt_comment") { queue_option_varlen(1, $val);
	##### Section Header Block options
	} elsif ($name eq "shb_hardware") { queue_option_varlen(2, $val)
	} elsif ($name eq "shb_os") { queue_option_varlen(3, $val);
	} elsif ($name eq "shb_userappl") { queue_option_varlen(4, $val);

	} elsif ($name eq "if_name") { queue_option_varlen(2, $val);
	} elsif ($name eq "if_tsresol") {
		queue_u16(9); # option #
		queue_u16(1); # length
		queue_u8($val);
		queue_pad_bytes(3);
	} elsif ($name eq "if_filter") { queue_option_varlen(11, $val);
	} elsif ($name eq "if_os") { queue_option_varlen(12, $val);

	}
}

sub output_SHB {
	print_magic();

	queue_byte_order_magic();
	queue_version(1, 0);
	queue_u64(0xffffffffffffffff); # section length - use -1 for 'figure it out'
	# block total length (32 bits) -- same as above

	# OS option
	queue_option('opt_comment', "syslog-to-pcap");
	#queue_option("opt_comment", "Generated from input file Standard input.");
	#queue_option("shb_userappl", "Text2pcap (Wireshark) 3.4.7 (Git commit e42cbf6a415f)");

	#queue_option(3, "Linux 3.10.0-1160.11.1.el7.x86_64");
	#queue_option(4, "Dumpcap 1.10.14 (Git Rev Unknown from unknown)");
	queue_end_of_options();
	output_queued();


	#########################################
sub encapsulate_block_data {
	my $block_type = shift;
	my $block_data = shift;

	pack('V V a* V',
		$block_type, length($block_data) + 12,
		$block_data, length($block_data) + 12);
}
	# block type (32 bits)
	# block total length (32 bits)
	# linktype (16 bits)
	# reserved (16 bits) -- must be 0
	# snaplen (32 bits) -- 0 means no limit

	# build an idb
	print_u32(1); # block type IDB
	# queue_u16(1); # linktype - ethernet - https://www.ietf.org/id/draft-tuexen-opsawg-pcapng-03.html#LINKTYPES
	# queue_u16(101); # linktype - DLT_RAW raw ip - https://www.ietf.org/id/draft-tuexen-opsawg-pcapng-03.html#LINKTYPES
	queue_u16($config{'linktype'});
	queue_u16(0); # reserved - must be 0
	queue_u32(256*1024); # snaplen - 0 = no limit

	queue_option("if_name", "syslog");

	# tsresol
	queue_option("if_tsresol", 6);

	#queue_option(11, "\0tcp port 2049 or udp port 514"); # prefixed by an octet designating the type of filter
	#queue_option(12, "Linux 3.10.0-1160.11.1.el7.x86_64");

	queue_end_of_options();
	output_queued();

}

sub htons {
	return (($_[0] >> 8) & 0xff) + (($_[0] << 8) & 0xff00);
}
sub ntohs { return htons($_[0]); }

sub u16_endian { (($_[0] >> 8) & 0xff) + (($_[0] & 0xff) << 8); }
sub u32_endian {
	(($_[0] >> 24) & 0x000000ff) + (($_[0] >> 8) & 0x0000ff00) +
	(($_[0] << 8) & 0x00ff0000) + (($_[0] <<24) & 0xff000000); }
sub endian_u16 { u16_endian($_[0]); }
sub endian_u32 { u32_endian($_[0]); }
sub ts_to_sec {
	my $ts = shift;

	my $h = substr($ts, 0, 2) + 0;
	my $m = substr($ts, 3, 2) + 0;
	my $s = substr($ts, 6) + 0;

	return (($h*60)+$m)*60 + $s;
}
sub sec_to_ts {
	my $s = shift;
	my $us = int(($s * 1000000) % 1000000);
	$s = int($s);
	my $m = int($s / 60);
	$s -= (60 * $m);
	my $h = int($m / 60);
	$m -= (60 * $h);

	return sprintf("%02d:%02d:%02d.%06d", $h, $m, $s, $us);
}
sub calc_udp_chksum {
	my $srcip = shift;
	my $dstip = shift;
	my $payload = shift;
	my $chksum = 0;

	my $pseudo = pack('N N n n n',
		$srcip,
		$dstip,
		0,
		17,
		length($payload));

        foreach my $add (unpack('n*', $pseudo . $payload . "\0")) {
		printf STDERR " adding 0x%04x to chksum\n", $add & 0xffff if ($config{'debug'} >= 2);
		$chksum += $add;
	}
	while ($chksum >> 16) {
		$chksum = ($chksum & 0xffff) + ($chksum >> 16);
	}
	return (~$chksum) & 0xffff;
}
sub construct_EPB_opts {
	my $epb_opts = '';
	# add epb options
	$epb_opts .= bytes_u16(0x0002); # epb_flags
	$epb_opts .= bytes_u8(0x04); # length of epb_flags
	# bits 16-31 - LL depenent errors
	# bits 9-15 - reserved - must be 0
	# bits 5-8 - fcs length, in octets (0000 if not available)
	# bits 2-4 - reception type
	#     000 - not specified
	#     001 - unicast
	#     010 - multicast
	#     011 - broadcast
	#     100 - promisc
	$epb_opts .= bytes_u16(0x0002); # multicast
	$epb_opts .= bytes_u8(0); # pad to 32-bit
	$epb_opts .= bytes_u8(0); # pad to 32-bit
	$epb_opts .= bytes_u8(0); # pad to 32-bit
	return $epb_opts;
}
sub construct_EPB {
	my $ts = shift;
	my $ts_subsec = shift;
	my $payload = shift;
	my $payload_len = length($payload);

	# frame
	$ts *= (10**$config{'subsec_digits'});
	$ts += $ts_subsec;

	my $ret = pack('V V V V V a* a*',
		0, # interface id
		($ts >> 32) & 0xffffffff,
		$ts & 0xffffffff,
		length($payload),
		length($payload),
		$payload . pad_bytes(calc_pad_bytes(length($payload))),
		construct_EPB_opts(),
	);

	return encapsulate_block_data(EPB, $ret);
}

sub construct_eth { # irrelevant if encapsulated directly as IP
	return pack('H* H* n',
		'0a0202020201',  # dst eth
		'0a0202020202',  # src eth
		$_[0] # type
	);
}

sub construct_ipv4 {
	my $srcip = shift;
	my $dstip = shift;
	my $payload = shift;

	my $chksum = 0;

	my $ip_hdr = pack('H2 B8 n2 B16 C2 n N2',
		'45',
		'000000' . '00', # 6 bits dscp, 2 bits ecn
		length($payload) + IP_HEADER_LEN,
		$config{'ip_id'},
		'0' . '0' . '0' . '0000000000000', # reserved: 0, DF: 0, more frags: 0, frag_offset: 0
		$config{'ip_ttl'},
		IPPROTO_UDP,
		0, # ip chksum
		$srcip, $dstip);

	foreach my $add (unpack('n*', $ip_hdr)) {
		$chksum += $add;
		$chksum = (($chksum & 0xffff) + (($chksum >> 16) & 0xffff)) & 0xffff;
		printf STDERR "adding 0x%04x to ip chksum\n", $add & 0xffff if ($config{'debug'} >= 2);
	}
	$chksum = $chksum ^ 0xffff;

	$ip_hdr = pack('H2 B8 n2 B16 C2 n N2',
		'45',
		'000000' . '00', # 6 bits dscp, 2 bits ecn
		length($payload) + IP_HEADER_LEN,
		$config{'ip_id'},
		'0' . '0' . '0' . '0000000000000', # reserved: 0, DF: 0, more frags: 0, frag_offset: 0
		$config{'ip_ttl'},
		IPPROTO_UDP,
		$chksum, # ip chksum
		$srcip, $dstip);

	return $ip_hdr . $payload;
}
sub construct_udp {
	my $srcip = shift;
	my $dstip = shift;
	my $srcport = shift;
	my $dstport = shift;
	my $payload = shift;
	my $chksum = 0;

	my $udp_hdr = pack('n n n n',
		$srcport,
		$dstport,
		length($payload) + 8,
		0); # checksum currently zero


	$chksum = calc_udp_chksum($srcip, $dstip, $udp_hdr . $payload);
	printf STDERR "udp checksum: 0x%04x\n", $chksum & 0xffff if ($config{'debug'} >= 2);

	$udp_hdr = pack('n n n n', # rebuild the header, now that we have the checksum
		$srcport,
		$dstport,
		length($payload) + 8,
		$chksum);

	return $udp_hdr . $payload;
}

sub output_udp_syslog_frame {
	my $ts = shift;
	my $ts_subsec = shift;
	my $payload = shift;

	if (!defined($payload)) {
		printf STDERR "payload isn't defined?\n";
		dump_backtrace();
		exit;
	}

	$payload = construct_udp($config{'src_ip'}, $config{'dst_ip'}, $config{'src_port'}, $config{'dst_port'}, $payload);
	$payload = construct_ipv4($config{'src_ip'}, $config{'dst_ip'}, $payload);

	if ($config{'linktype'} eq LINKTYPE_ETH) {
		$payload = construct_eth(0x0800) . $payload;
	} elsif ($config{'linktype'} eq LINKTYPE_DLT_RAW) {
		# nothing to do
	}

	my $EPB_data = construct_EPB($ts, $ts_subsec, $payload);

	printf "%s", $EPB_data;
}

die("must give input filename") if (!defined($ARGV[0]));

my $input;
if ($ARGV[0] eq "-") {
	$input = \*STDIN;
} else {
	open($input, '<', $ARGV[0]) or die("could not open file '" . $ARGV[0] . "': $!");
}

output_SHB();
# header is complete...  now start creating syslog frames containing strace lines




my $line_num = 0;
while (<$input>) {
	my $line = $_;
	my $ts;
	my $ts_subsec;
	my $message;

	$line = trim($line);
	$line_num++;
	my ($date, $time, $tz);

	if (($ts, $ts_subsec, $message) = $line =~ $regexes{'epoch_line'}) {
		# nothing more to do
		printf STDERR "parsed timestamp into %d.%06d - %s\n", $ts, $ts_subsec, $line if ($config{'debug'} >= 1);
	} elsif (($date, $time, $ts_subsec, $tz, $message) = $line =~ $regexes{'iso_3339_line'}) {
		my $tmpstr = sprintf("%s %s %s\n", $date, $time, $tz);

		$ts = $time_parser->parse_datetime($tmpstr)->epoch;
	} elsif (($date, $time, $ts_subsec, $tz, $message) = $line =~ $regexes{'iso_8601_line'}) {
		my $tmpstr = sprintf("%s %s %s\n", $date, $time, $tz);

		$ts = $time_parser->parse_datetime($tmpstr)->epoch;
	} else { # I guess this is just a raw message that is occurring _right_now_
		$message = $line;
		($ts, $ts_subsec) = gettimeofday; # subsec is in microseconds
		$ts_subsec *= 10**($config{'subsec_digits'} - 6);
	}

	$ts += $config{'ts_adjust'};
	$ts_subsec += $config{'ts_subsec_adjust'};

	while ($ts_subsec > 10**$config{'subsec_digits'}) {
		$ts_subsec -= 10**$config{'subsec_digits'};
		$ts ++;
	}

	output_udp_syslog_frame($ts, $ts_subsec, $message);
}

if ($ARGV[0] ne "-") {
	close($input);
}
